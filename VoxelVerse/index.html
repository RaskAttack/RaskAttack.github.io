<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VoxelVerse - by oiPoipoi Games</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        :root {
            /* Dark Theme (Default) */
            --bg-main: #0f172a;
            --bg-panel: rgba(15, 23, 42, 0.95);
            --bg-element: #1e293b;
            --bg-element-hover: #334155;
            --text-main: #f8fafc;
            --text-muted: #94a3b8;
            --border-color: #334155;
            
            --accent: #38bdf8;
            --accent-hover: #0ea5e9;
            --danger: #ef4444;
            --warning: #f59e0b;
            --dev: #eab308;
            --ai: #a855f7;
        }

        body.light-mode {
            /* Light Theme */
            --bg-main: #f1f5f9;
            --bg-panel: rgba(255, 255, 255, 0.95);
            --bg-element: #ffffff;
            --bg-element-hover: #e2e8f0;
            --text-main: #0f172a;
            --text-muted: #64748b;
            --border-color: #cbd5e1;
        }

        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', system-ui, sans-serif; background: var(--bg-main); color: var(--text-main); user-select: none; transition: background 0.3s, color 0.3s; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; }
        
        #toolbar { 
            pointer-events: auto; 
            background: var(--bg-panel); 
            padding: 8px 16px; 
            display: flex; 
            gap: 8px; 
            align-items: center; 
            border-bottom: 1px solid var(--border-color);
            height: 54px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            overflow-x: auto;
            scrollbar-width: thin;
        }

        .logo { 
            font-weight: 900; font-size: 22px; 
            background: linear-gradient(135deg, #38bdf8, #818cf8);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-right: 10px; letter-spacing: -0.5px; 
            text-transform: uppercase;
            text-shadow: 0 2px 10px rgba(56, 189, 248, 0.3);
            flex-shrink: 0;
        }

        .btn {
            background: var(--bg-element); border: 1px solid var(--border-color); color: var(--text-main); padding: 8px 12px; 
            border-radius: 8px; cursor: pointer; font-size: 13px; font-weight: 600; transition: all 0.2s;
            display: flex; align-items: center; gap: 6px; box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            flex-shrink: 0; white-space: nowrap;
        }
        .btn:hover { background: var(--bg-element-hover); transform: translateY(-1px); }
        .btn:active { transform: translateY(0); }
        
        /* Tool Button Styling */
        .btn.tool-btn { border-left: 3px solid transparent; }
        .btn.tool-btn.active { 
            background: rgba(56, 189, 248, 0.15); 
            border-color: var(--accent); 
            color: var(--accent);
            box-shadow: inset 0 0 8px rgba(56, 189, 248, 0.2);
        }

        .btn.primary { background: var(--accent); color: #0f172a; border: none; }
        .btn.primary:hover { background: var(--accent-hover); box-shadow: 0 0 15px rgba(56, 189, 248, 0.4); color: white; }
        
        .btn.danger { background: rgba(239, 68, 68, 0.15); color: #fca5a5; border-color: rgba(239, 68, 68, 0.3); }
        .btn.danger:hover { background: rgba(239, 68, 68, 0.25); }
        
        .btn.dev { background: rgba(234, 179, 8, 0.15); color: #fde047; border-color: rgba(234, 179, 8, 0.3); }
        .btn.dev:hover { background: rgba(234, 179, 8, 0.25); box-shadow: 0 0 10px rgba(234, 179, 8, 0.3); }

        .btn.ai { background: rgba(168, 85, 247, 0.15); color: #d8b4fe; border-color: rgba(168, 85, 247, 0.3); }
        .btn.ai:hover { background: rgba(168, 85, 247, 0.25); box-shadow: 0 0 15px rgba(168, 85, 247, 0.3); }

        select, input[type="number"], input[type="text"], input[type="password"], input[type="color"] {
            background: var(--bg-element); border: 1px solid var(--border-color); color: var(--text-main); padding: 8px; border-radius: 8px; outline: none; cursor: pointer;
        }
        
        .control-group { 
            display: flex; align-items: center; gap: 4px; background: var(--bg-element); padding: 4px 8px; 
            border-radius: 8px; border: 1px solid var(--border-color); flex-shrink: 0;
        }
        .label { font-size: 10px; color: var(--text-muted); font-weight: 700; text-transform: uppercase; margin-right: 4px; }
        .checkbox-wrapper { display: flex; align-items: center; gap: 6px; cursor: pointer; font-size: 12px; font-weight: 600; color: var(--text-muted); }
        input[type="checkbox"] { accent-color: var(--accent); width: 16px; height: 16px; cursor: pointer; }

        #palette {
            pointer-events: auto;
            position: absolute; left: 16px; top: 80px; bottom: 40px;
            width: 100px;
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            display: flex; flex-direction: column; gap: 8px; padding: 12px 8px;
            overflow-y: auto;
            backdrop-filter: blur(10px);
            scrollbar-width: none;
        }

        .tool-item {
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: rgba(125,125,125,0.05); border: 1px solid transparent;
            border-radius: 10px; padding: 10px 4px; cursor: pointer; transition: all 0.2s;
            position: relative;
        }
        .tool-item:hover { background: rgba(125,125,125,0.1); }
        .tool-item.selected { background: rgba(56, 189, 248, 0.15); border-color: var(--accent); }
        .tool-item.dev-item { border: 1px dashed var(--dev); }
        .tool-item.custom-item { border: 1px solid var(--accent); }
        
        .tool-icon { font-size: 26px; margin-bottom: 4px; filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2)); }
        .tool-label { font-size: 11px; color: var(--text-muted); text-align: center; font-weight: 600; }
        .tool-item.selected .tool-label { color: var(--accent); }

        #controls-info {
            position: absolute; bottom: 20px; right: 20px;
            background: var(--bg-panel); padding: 15px; border-radius: 12px;
            font-size: 12px; color: var(--text-muted); pointer-events: none;
            border: 1px solid var(--border-color);
            backdrop-filter: blur(4px);
        }
        .key { background: var(--bg-element-hover); padding: 2px 6px; border-radius: 4px; color: var(--text-main); font-family: monospace; border-bottom: 2px solid var(--border-color); }
        .row { margin-bottom: 6px; display: flex; justify-content: space-between; width: 220px; }

        #credits {
            position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
            font-size: 12px; color: var(--text-muted); font-weight: 600; pointer-events: none;
            text-transform: uppercase; letter-spacing: 1px; opacity: 0.5;
        }

        #play-ui { display: none; position: absolute; top: 20px; left: 50%; transform: translateX(-50%); }
        .score-pill { 
            background: var(--bg-panel); padding: 10px 24px; border-radius: 30px; 
            border: 2px solid var(--accent); font-size: 20px; font-weight: bold; 
            display: flex; align-items: center; gap: 10px; color: var(--text-main);
            box-shadow: 0 0 20px rgba(56, 189, 248, 0.3);
        }

        #game-over { 
            display: none; position: absolute; inset: 0; background: rgba(0,0,0,0.9); 
            align-items: center; justify-content: center; flex-direction: column; pointer-events: auto; z-index: 100;
        }
        #go-title {
            font-size: 4rem; margin-bottom: 20px; color: white;
            text-shadow: 0 0 30px var(--accent);
            font-weight: 900;
        }
        
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 6px; height: 6px;
            background: white; border-radius: 50%; transform: translate(-50%, -50%);
            pointer-events: none; mix-blend-mode: difference;
        }

        #toast {
            position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%);
            background: var(--accent); color: #0f172a; padding: 8px 24px; border-radius: 20px;
            font-weight: 600; opacity: 0; transition: opacity 0.3s; pointer-events: none;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3);
            z-index: 500;
        }
        
        #god-mode-indicator {
            display: none; position: absolute; top: 80px; left: 50%; transform: translateX(-50%);
            color: var(--dev); font-weight: bold; font-size: 14px; text-shadow: 0 0 10px var(--dev);
        }

        /* Modal Styles */
        #modal-overlay, #settings-overlay {
            display: none; position: absolute; inset: 0; background: rgba(0,0,0,0.8);
            align-items: center; justify-content: center; z-index: 200; pointer-events: auto;
        }
        .modal {
            background: var(--bg-element); padding: 24px; border-radius: 16px; width: 360px;
            border: 1px solid var(--border-color); box-shadow: 0 20px 25px -5px rgba(0,0,0,0.5);
            max-height: 90vh; overflow-y: auto;
        }
        .modal h3 { margin-top: 0; color: var(--text-main); margin-bottom: 16px; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; }
        .modal input[type="text"], .modal input[type="number"], .modal input[type="password"] { 
            width: 100%; padding: 10px; margin-bottom: 16px; background: var(--bg-main); 
            border: 1px solid var(--border-color); color: var(--text-main); border-radius: 8px; box-sizing: border-box;
        }
        .modal textarea {
            width: 100%; padding: 10px; margin-bottom: 16px; background: var(--bg-main); 
            border: 1px solid var(--border-color); color: #a7f3d0; border-radius: 8px; box-sizing: border-box;
            font-family: monospace; height: 100px; resize: vertical;
        }
        .modal-buttons { display: flex; gap: 10px; justify-content: flex-end; }
        .setting-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; font-size: 14px; color: var(--text-muted); }
        .disclaimer-box { background: rgba(0,0,0,0.2); padding: 10px; border-radius: 6px; font-size: 11px; margin-top: 20px; color: var(--text-muted); border: 1px solid var(--border-color); font-style: italic;}

        /* Pixel Painter */
        #pixel-grid { 
            display: grid; grid-template-columns: repeat(16, 1fr); gap: 1px; background: #333; border: 1px solid #555; margin-bottom: 15px; 
            user-select: none; touch-action: none;
        }
        .pixel-cell { width: 100%; aspect-ratio: 1; background: #fff; cursor: pointer; }
        .pixel-cell:hover { opacity: 0.8; }

        /* Start Screen for Exported Games */
        #start-screen {
            display: none; position: absolute; inset: 0; background: var(--bg-main);
            align-items: center; justify-content: center; flex-direction: column; z-index: 300; pointer-events: auto;
        }
        #start-screen h1 { font-size: 60px; margin: 0 0 20px 0; color: var(--accent); text-shadow: 0 0 30px var(--accent); text-align: center; }
        #start-screen p { color: var(--text-muted); margin-bottom: 40px; }

        body.exported #toolbar, 
        body.exported #palette, 
        body.exported #controls-info,
        body.exported #btn-editor-return { display: none !important; }
        
        #loading-ai { display: none; color: var(--ai); font-weight: bold; margin-top: 10px; text-align: center; }
        
        @media (max-width: 1100px) { .btn-text { display: none; } .btn { padding: 8px; } }
    </style>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div id="toolbar">
            <div class="logo">VoxelVerse</div>
            <div style="width: 1px; height: 20px; background: var(--border-color); margin: 0 5px;"></div>
            
            <button class="btn tool-btn active" id="tool-brush" onclick="selectToolMode('brush')" title="Brush (Place Blocks)">üß±</button>
            <button class="btn tool-btn" id="tool-fill" onclick="selectToolMode('fill')" title="Box Fill">üî≤</button>
            <button class="btn tool-btn" id="tool-eraser" onclick="selectToolMode('eraser')" title="Eraser">‚ùå</button>
            <button class="btn tool-btn" id="tool-pick" onclick="selectToolMode('pick')" title="Picker">üíâ</button>
            
            <div style="width: 1px; height: 20px; background: var(--border-color); margin: 0 5px;"></div>
            
            <select id="level-select" onchange="switchLevel(this.value)" title="Select Level" style="max-width: 100px;"></select>
            <button class="btn" onclick="openModal('level')" title="New Level">‚ûï</button>
            <button class="btn danger" onclick="deleteLevel()" title="Delete Level">üóëÔ∏è</button>
            <button class="btn danger" onclick="clearCurrentLevel()" title="Clear All Blocks">üßπ</button>
            
            <div style="width: 1px; height: 20px; background: var(--border-color); margin: 0 5px;"></div>
            
            <div class="control-group">
                <span class="label">Lyr</span>
                <input type="number" id="layer-input" value="0" style="width: 40px;" onchange="updateBuildLayer(this.value)">
                <label class="checkbox-wrapper">
                    <input type="checkbox" id="force-layer" onchange="toggleForceLayer(this.checked)"> Force
                </label>
            </div>

            <div class="control-group" style="margin-left: 10px;">
                <span class="label">Size</span>
                <input type="number" id="scale-x" value="1" step="0.1" min="0.1" max="10" style="width: 35px;" onchange="updateBuildScale()" title="X Size">
                <input type="number" id="scale-y" value="1" step="0.1" min="0.1" max="10" style="width: 35px;" onchange="updateBuildScale()" title="Y Size">
                <input type="number" id="scale-z" value="1" step="0.1" min="0.1" max="10" style="width: 35px;" onchange="updateBuildScale()" title="Z Size">
            </div>

            <div style="flex-grow: 1;"></div>
            <button class="btn ai" id="btn-ai-gen" onclick="openModal('ai-gen')" title="Generate Level with AI" style="display:none;">‚ú® <span class="btn-text">AI Gen</span></button>
            <button class="btn" onclick="openModal('block-maker')" title="Block Maker">üî® <span class="btn-text">Builder</span></button>
            <button class="btn" onclick="openImport()" title="Import HTML">üì• <span class="btn-text">Import</span></button>
            <button class="btn" onclick="openExportModal()" title="Export HTML">üì¶ <span class="btn-text">Export</span></button>
            <button class="btn" onclick="saveProject()">üíæ <span class="btn-text">Save</span></button>
            <button class="btn" onclick="openSettings()" title="Settings">‚öôÔ∏è</button>
            <div style="width: 1px; height: 20px; background: var(--border-color); margin: 0 5px;"></div>
            <button class="btn primary" id="btn-play" onclick="togglePlayMode()">‚ñ∂ PLAY</button>
        </div>

        <div id="palette"></div>

        <div id="controls-info">
            <div class="row"><span>Move Cam</span> <span><span class="key">WASD</span></span></div>
            <div class="row"><span>Look</span> <span><span class="key">R-Click</span> + Drag</span></div>
            <div class="row"><span>Up/Down</span> <span><span class="key">Space</span>/<span class="key">Ctrl</span></span></div>
            <div class="row"><span>Interact</span> <span><span class="key">L-Click</span></span></div>
            <div class="row"><span>Pick</span> <span><span class="key">R-Click</span> Block</span></div>
        </div>
        
        <div id="credits">Made by oiPoipoi Games</div>

        <div id="play-ui">
            <div class="score-pill"><span>ü™ô</span> <span id="coin-count">0</span></div>
            <div style="margin-top: 10px; text-align: center; color: rgba(255,255,255,0.6); font-size: 12px; font-weight: 500;">
                <span class="key" style="background: rgba(255,255,255,0.2);">ESC</span> Pause / <span class="key" style="background: rgba(255,255,255,0.2);">R</span> Restart / <span class="key" style="background: rgba(255,255,255,0.2);">Space</span> Jump / <span class="key" style="background: rgba(255,255,255,0.2);">W</span> Climb
            </div>
            <div id="god-mode-indicator">‚ö° GOD MODE ACTIVE ‚ö°</div>
        </div>

        <div id="crosshair"></div>
        <div id="toast">Saved!</div>
    </div>

    <!-- Hidden File Input for Import -->
    <input type="file" id="import-file" style="display:none" accept=".html" onchange="handleFileSelect(this)">

    <!-- Input Modal -->
    <div id="modal-overlay">
        <div class="modal">
            <h3 id="modal-title">Input</h3>
            
            <div id="modal-content-default">
                <input type="text" id="modal-input" placeholder="...">
                <div id="loading-ai">Thinking... ‚ú®</div>
            </div>
            
            <!-- Export Specific Content -->
            <div id="modal-content-export" style="display:none;">
                <div class="setting-row">
                    <label>Game Title</label>
                </div>
                <input type="text" id="export-title" placeholder="My Awesome Game" value="VoxelVerse Game">
                <div class="setting-row">
                    <label>Button Text</label>
                </div>
                <input type="text" id="export-btn-text" placeholder="CLICK TO START" value="CLICK TO START">
            </div>

            <!-- Block Maker Content -->
            <div id="modal-content-block" style="display:none;">
                <div class="setting-row">
                    <input type="text" id="bm-name" placeholder="Block Name (e.g. Mega Jump)">
                </div>
                
                <div style="display:flex; gap:10px;">
                    <div style="flex:1;">
                        <label class="label">Behavior</label>
                        <select id="bm-type" style="width: 100%;">
                            <option value="solid">Solid (Standard)</option>
                            <option value="bounce">Bouncy</option>
                            <option value="hazard">Hazard (Deadly)</option>
                            <option value="ice">Ice (Slippery)</option>
                            <option value="mud">Mud (Slow)</option>
                            <option value="speed">Speed Pad</option>
                        </select>
                    </div>
                    <div style="flex:1;">
                         <label class="label">Effect Strength</label>
                        <input type="number" id="bm-force" value="1.5" step="0.1" style="width: 100%;">
                    </div>
                </div>

                <div style="margin-top:15px;">
                    <label class="label">Texture Editor (16x16)</label>
                    <div style="display:flex; justify-content:space-between; margin-bottom:5px; gap:5px;">
                        <input type="color" id="bm-paint-color" value="#ffffff" style="height:30px; flex-grow:1;">
                        <button class="btn" id="bm-fill-btn" onclick="toggleFillMode()" style="font-size: 12px; width: 80px;">ü™£ Fill</button>
                    </div>
                    <div id="pixel-grid" onmouseleave="isPainting=false"></div>
                </div>

                <div style="margin-top:15px;">
                     <label class="label">Custom Script (On Touch)</label>
                     <textarea id="bm-script" placeholder="// player.velocity.y = 20;"></textarea>
                </div>

                 <div style="margin-top: 15px; border-top: 1px solid #333; padding-top: 10px;">
                    <div style="font-size: 12px; color: var(--ai); margin-bottom: 5px;">Or ask AI to configure:</div>
                    <input type="text" id="bm-ai-prompt" placeholder="E.g. A green block that bounces you high">
                    <button class="btn ai" style="width:100%; margin-top:5px;" onclick="generateBlockAI()">Generate Config ‚ú®</button>
                </div>
            </div>

            <div class="modal-buttons" style="margin-top: 20px;">
                <button class="btn" onclick="closeModal()">Cancel</button>
                <button class="btn primary" onclick="submitModal()">Confirm</button>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settings-overlay">
        <div class="modal">
            <h3>Settings</h3>
            <div class="setting-row">
                <label class="checkbox-wrapper">
                    <input type="checkbox" id="light-mode-toggle" onchange="toggleTheme(this.checked)"> Light Mode
                </label>
            </div>
            <div class="setting-row">
                <span>Block Count:</span> <span id="block-count-display">0 / 2000</span>
            </div>
            
            <div class="setting-row" style="margin-top: 15px; padding-top: 10px; border-top: 1px solid var(--border-color);">
                <strong style="color: var(--ai);">AI Configuration</strong>
            </div>
            <div class="setting-row">
                 <label class="checkbox-wrapper">
                    <input type="checkbox" id="ai-toggle" onchange="toggleAiFeature(this.checked)"> Show AI Tools
                </label>
            </div>
            <div id="ai-key-container" style="margin-bottom: 15px;">
                <input type="password" id="api-key-input" placeholder="Paste Gemini API Key" onblur="saveApiKey(this.value)">
                <div style="font-size: 10px; color: var(--text-muted); margin-top: 4px;">Key stored locally in your browser.</div>
            </div>

            <div class="setting-row" style="margin-top: 15px; padding-top: 10px; border-top: 1px solid var(--border-color);">
                 <strong>Developer</strong>
            </div>
            <div class="setting-row">
                <input type="text" id="dev-code-input" placeholder="Dev Code..." style="margin-bottom:0; width: 60%;">
                <button class="btn" onclick="checkDevCode()">Unlock</button>
            </div>
            <div id="dev-controls" style="display:none; margin-top:10px;">
                <div style="color:var(--dev); font-weight:bold; margin-bottom:5px;">DEV MODE UNLOCKED</div>
                <label class="checkbox-wrapper">
                    <input type="checkbox" id="dev-toggle" checked onchange="toggleDevMode(this.checked)"> Enable No Limits
                </label>
            </div>

            <div class="setting-row" style="margin-top: 15px;">
                 <button class="btn danger" onclick="resetSaveData()" style="width: 100%;">Reset All Data</button>
            </div>
            
            <div class="disclaimer-box">
                <strong>Disclaimer:</strong> This engine was made with AI. A version made with Godot is currently in development.
            </div>
            <div class="modal-buttons" style="margin-top:20px;">
                <button class="btn primary" onclick="closeSettings()">Close</button>
            </div>
        </div>
    </div>

    <!-- Start Screen (Exported Only) -->
    <div id="start-screen">
        <h1 id="start-title">VOXELVERSE</h1>
        <p>Made by oiPoipoi Games</p>
        <button class="btn primary" id="start-btn" onclick="startGame()" style="font-size: 24px; padding: 20px 40px;">CLICK TO START</button>
    </div>

    <div id="game-over">
        <h1 id="go-title">PAUSED</h1>
        <div style="display: flex; gap: 20px; flex-wrap: wrap; justify-content: center;">
            <button class="btn primary" id="btn-resume" onclick="resumeGame()" style="padding: 12px 24px; font-size: 1.2rem;">Resume</button>
            <button class="btn primary" id="btn-next-level" onclick="nextLevel()" style="display:none; padding: 12px 24px; font-size: 1.2rem;">Next Level ‚û°</button>
            <button class="btn" onclick="restartLevel()" style="padding: 12px 24px; font-size: 1.2rem;">Restart (R)</button>
            <button class="btn danger" id="btn-editor-return" onclick="stopGame()" style="padding: 12px 24px; font-size: 1.2rem;">Quit to Editor</button>
        </div>
    </div>

<script>
/**
 * VOXELVERSE ENGINE v7.3
 * Made by oiPoipoi Games
 */

// --- TWEEN ENGINE (Moved Up to Fix Crash) ---
const easingElastic = t => {
    const c4 = (2 * Math.PI) / 3;
    return t === 0 ? 0 : t === 1 ? 1 : -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * c4);
};

const TWEEN_REGISTRY = [];
class TWEEN {
    constructor(target) { this.target = target; this.toVals = {}; this.duration = 1000; this.startTime = 0; this.started = false; this.startVals = {}; this.easingFn = t => t; }
    to(vals, dur) { this.toVals = vals; this.duration = dur; return this; }
    easing(fn) { this.easingFn = fn; return this; }
    start() { 
        this.startTime = performance.now(); 
        this.started = true;
        for(let k in this.toVals) this.startVals[k] = this.target[k];
        TWEEN_REGISTRY.push(this);
    }
    update(t) {
        const progress = Math.min(1, (t - this.startTime) / this.duration);
        const eased = this.easingFn(progress);
        for(let k in this.toVals) {
            this.target[k] = this.startVals[k] + (this.toVals[k] - this.startVals[k]) * eased;
        }
        return progress >= 1;
    }
}

// --- CONFIG & LIMITS ---
const CONFIG = {
    cellSize: 1,
    gravity: 40,
    baseMoveSpeed: 10,
    jumpForce: 14,
    colors: {
        sky: 0x0f172a,
        grid: 0x1e293b,
        skyLight: 0xf1f5f9
    }
};

const LIMITS = {
    BLOCKS: 2000,
    LAYER_MAX: 100,
    LAYER_MIN: -5,
    SIZE: 50
};

// --- GLOBAL STATE ---
let mode = 'edit';
let project = {
    levels: [ { id: 'lvl1', name: 'Level 1', objects: [] } ],
    currentLevelId: 'lvl1',
    customBlocks: []
};
let objects = []; 
let currentBlockType = 'brick'; // Renamed from selectedTool
let currentTool = 'brush';      // 'brush', 'fill', 'eraser', 'pick'
let isExported = false;
let devMode = false;
let godMode = false;
let gameEnded = false;
let bullets = []; 
let pendingPlaceCoords = null; 
let buildLayerY = 0; 
let forceLayer = false;
let buildScale = { x: 1, y: 1, z: 1 };
let isLightMode = false;
let userApiKey = "";
let aiEnabled = true;
let isFillMode = false;
let isPainting = false;
let fillStart = null; 

// Physics State
let player = {
    pos: new THREE.Vector3(0, 5, 0),
    vel: new THREE.Vector3(),
    onGround: false,
    radius: 0.3,
    height: 1.6,
    friction: 10,
    speedMod: 1,
    onLadder: false
};

const input = { keys: {}, mouse: new THREE.Vector2(), mouseDown: false, rightDown: false };

// --- THREE.JS INIT ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(CONFIG.colors.sky);
scene.fog = new THREE.FogExp2(CONFIG.colors.sky, 0.02);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.rotation.order = 'YXZ'; 

const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.getElementById('canvas-container').appendChild(renderer.domElement);

// Lights
const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
scene.add(hemiLight);

const dirLight = new THREE.DirectionalLight(0xffffff, 1);
dirLight.position.set(15, 30, 15);
dirLight.castShadow = true;
dirLight.shadow.mapSize.width = 2048;
dirLight.shadow.mapSize.height = 2048;
dirLight.shadow.camera.near = 0.5;
dirLight.shadow.camera.far = 100;
dirLight.shadow.camera.left = -30;
dirLight.shadow.camera.right = 30;
dirLight.shadow.camera.top = 30;
dirLight.shadow.camera.bottom = -30;
dirLight.shadow.bias = -0.0005;
scene.add(dirLight);

const gridHelper = new THREE.GridHelper(100, 100, 0x334155, 0x1e293b);
scene.add(gridHelper);

// --- MODAL SYSTEM ---
let activeModalType = null;
let painterPixels = new Array(256).fill('#ffffff'); // 16x16

function openModal(type) {
    activeModalType = type;
    const modal = document.getElementById('modal-overlay');
    const title = document.getElementById('modal-title');
    const input = document.getElementById('modal-input');
    const defaultContent = document.getElementById('modal-content-default');
    const exportContent = document.getElementById('modal-content-export');
    const blockContent = document.getElementById('modal-content-block');
    const loading = document.getElementById('loading-ai');
    
    modal.style.display = 'flex';
    input.value = '';
    loading.style.display = 'none'; 
    
    defaultContent.style.display = 'none';
    exportContent.style.display = 'none';
    blockContent.style.display = 'none';

    if (type === 'dev') {
        title.innerText = "Enter Developer Code";
        defaultContent.style.display = 'block';
        input.placeholder = "Code...";
        input.focus();
    } else if (type === 'level') {
        title.innerText = "New Level Name";
        defaultContent.style.display = 'block';
        input.placeholder = "Level Name...";
        input.focus();
    } else if (type === 'sign') {
        title.innerText = "Enter Sign Text";
        defaultContent.style.display = 'block';
        input.placeholder = "Your text here...";
        input.focus();
    } else if (type === 'ai-gen') {
        title.innerText = "Generate Level with AI ‚ú®";
        defaultContent.style.display = 'block';
        input.placeholder = "E.g., A parkour course over lava...";
        input.focus();
    } else if (type === 'block-maker') {
        title.innerText = "Create Custom Block";
        blockContent.style.display = 'block';
        initPixelGrid();
        document.getElementById('bm-name').focus();
    }
}

function openExportModal() {
    activeModalType = 'export';
    const modal = document.getElementById('modal-overlay');
    const title = document.getElementById('modal-title');
    const defaultContent = document.getElementById('modal-content-default');
    const exportContent = document.getElementById('modal-content-export');
    const blockContent = document.getElementById('modal-content-block');
    
    modal.style.display = 'flex';
    title.innerText = "Export Settings";
    defaultContent.style.display = 'none';
    blockContent.style.display = 'none';
    exportContent.style.display = 'block';
}

function closeModal() {
    document.getElementById('modal-overlay').style.display = 'none';
    activeModalType = null;
    pendingPlaceCoords = null;
}

function submitModal() {
    const val = document.getElementById('modal-input').value;
    
    if (activeModalType === 'dev') {
        if (val === "oiPoipoiDEV") {
            devMode = true;
            showToast("Dev Mode Unlocked!");
            initPalette();
        } else {
            showToast("Incorrect Code");
        }
        closeModal();
    } else if (activeModalType === 'level') {
        if (val) performAddLevel(val);
        closeModal();
    } else if (activeModalType === 'sign') {
        if (val && pendingPlaceCoords) {
            addObject(pendingPlaceCoords.x, pendingPlaceCoords.y, pendingPlaceCoords.z, 'sign', val);
        }
        closeModal();
    } else if (activeModalType === 'export') {
        const title = document.getElementById('export-title').value || "VoxelVerse Game";
        const btnText = document.getElementById('export-btn-text').value || "CLICK TO START";
        performExport(title, btnText);
        closeModal();
    } else if (activeModalType === 'ai-gen') {
        if (val) generateLevelFromAI(val);
    } else if (activeModalType === 'block-maker') {
        createCustomBlockFromUI();
        closeModal();
    }
}

function selectToolMode(toolName) {
    currentTool = toolName;
    document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
    document.getElementById('tool-' + toolName).classList.add('active');
    fillStart = null;
}

function toggleFillMode() {
    isFillMode = !isFillMode;
    const btn = document.getElementById('bm-fill-btn');
    if(isFillMode) {
        btn.classList.add('primary');
        btn.style.border = "1px solid var(--accent)";
    } else {
        btn.classList.remove('primary');
        btn.style.border = "1px solid var(--border-color)";
    }
}

function initPixelGrid() {
    const grid = document.getElementById('pixel-grid');
    grid.innerHTML = '';
    painterPixels.fill('#ffffff'); 

    for(let i=0; i<256; i++) {
        const d = document.createElement('div');
        d.className = 'pixel-cell';
        d.style.backgroundColor = painterPixels[i]; 
        
        d.onmousedown = (e) => {
            e.preventDefault(); 
            if(isFillMode) {
                floodFill(i);
            } else {
                isPainting = true;
                paintPixel(i);
            }
        };
        
        d.onmouseenter = () => {
            if(isPainting && !isFillMode) {
                paintPixel(i);
            }
        };
        
        d.onmouseup = () => {
            isPainting = false;
        };

        grid.appendChild(d);
    }
    
    isFillMode = false;
    const btn = document.getElementById('bm-fill-btn');
    if(btn) {
        btn.classList.remove('primary');
        btn.style.border = "";
    }
}

function paintPixel(i) {
    const col = document.getElementById('bm-paint-color').value;
    painterPixels[i] = col;
    document.getElementById('pixel-grid').children[i].style.backgroundColor = col;
}

function floodFill(startIndex) {
    const targetColor = painterPixels[startIndex];
    const replacementColor = document.getElementById('bm-paint-color').value;
    if (targetColor === replacementColor) return;

    const stack = [startIndex];
    const seen = new Set(); 

    while (stack.length > 0) {
        const i = stack.pop();
        if (seen.has(i)) continue;
        seen.add(i);

        if (painterPixels[i] === targetColor) {
            paintPixel(i); 
            
            const x = i % 16;
            const y = Math.floor(i / 16);
            
            if (x > 0) stack.push(i - 1);
            if (x < 15) stack.push(i + 1);
            if (y > 0) stack.push(i - 16);
            if (y < 15) stack.push(i + 16);
        }
    }
}

// --- AI GENERATION ---
async function generateLevelFromAI(prompt) {
    if (!userApiKey) {
        showToast("Please set API Key in Settings");
        closeModal();
        openSettings();
        return;
    }

    const loading = document.getElementById('loading-ai');
    loading.style.display = 'block';
    
    const systemPrompt = `You are a Voxel Game Level Generator.
    Coordinates: x (horiz), y (vert, 0=floor), z (depth).
    Available Blocks: 'brick', 'grass', 'wood', 'ice' (slippery), 'mud' (slow), 'lava' (kill), 'bounce' (jump), 'coin', 'spawn' (START), 'goal' (END), 'turret' (shoot), 'tp' (teleport), 'speed', 'sand', 'stone', 'log', 'leaves', 'glass', 'light', 'ladder'.
    
    Task: Build a level based on the user request.
    Rules:
    1. Output strictly valid JSON array of objects: [{"x":0,"y":0,"z":0,"type":"grass"},...]
    2. MUST include 1 'spawn' and 1 'goal'.
    3. Make it playable (jumpable distances).
    4. Use verticality! Don't just build on y=0.
    5. Max 200 blocks.
    `;

    try {
        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${userApiKey}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                contents: [{
                    role: "user",
                    parts: [{ text: systemPrompt + "\n\nUser Request: " + prompt }]
                }]
            })
        });

        const data = await response.json();
        const text = data.candidates[0].content.parts[0].text;
        
        const jsonStr = text.replace(/```json/g, '').replace(/```/g, '').trim();
        const blocks = JSON.parse(jsonStr);

        if (Array.isArray(blocks)) {
            objects.forEach(o => scene.remove(o));
            objects = [];
            
            blocks.forEach(b => {
                addObject(b.x, b.y, b.z, b.type);
            });
            showToast("Level Generated! ‚ú®");
        }
    } catch (e) {
        console.error(e);
        showToast("AI Generation Failed.");
    } finally {
        closeModal();
    }
}

async function generateBlockAI() {
    if (!userApiKey) {
        showToast("Set API Key in Settings first");
        return;
    }
    
    const prompt = document.getElementById('bm-ai-prompt').value;
    if(!prompt) return;

    const btn = document.querySelector('#modal-content-block .btn.ai');
    btn.innerText = "Generating...";
    
    const systemPrompt = `You are a config generator for game blocks.
    Return JSON ONLY: {"name": string, "color": hex_string, "type": string, "force": number, "script": string}
    Types: 'solid', 'bounce', 'hazard', 'ice', 'mud', 'speed'.
    Script: A short JS one-liner for custom effects on collision (optional). e.g., "player.vel.y=30;"
    Example: {"name": "Slime", "color": "#00ff00", "type": "bounce", "force": 2.0}
    `;

    try {
         const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${userApiKey}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                contents: [{ role: "user", parts: [{ text: systemPrompt + "\n\nRequest: " + prompt }] }]
            })
        });
        
        const data = await response.json();
        const text = data.candidates[0].content.parts[0].text;
        const jsonStr = text.replace(/```json/g, '').replace(/```/g, '').trim();
        const conf = JSON.parse(jsonStr);
        
        document.getElementById('bm-name').value = conf.name;
        document.getElementById('bm-color').value = conf.color;
        document.getElementById('bm-type').value = conf.type;
        document.getElementById('bm-force').value = conf.force || 1.5;
        if(conf.script) document.getElementById('bm-script').value = conf.script;
        
    } catch(e) {
        showToast("AI Config Failed");
    } finally {
        btn.innerText = "Generate Config ‚ú®";
    }
}

// --- SETTINGS MENU ---
function openSettings() {
    document.getElementById('settings-overlay').style.display = 'flex';
    document.getElementById('block-count-display').innerText = `${objects.length} / ${LIMITS.BLOCKS}`;
    document.getElementById('light-mode-toggle').checked = isLightMode;
    document.getElementById('ai-toggle').checked = aiEnabled;
    document.getElementById('api-key-input').value = userApiKey;
    document.getElementById('ai-key-container').style.display = aiEnabled ? 'block' : 'none';
    
    if(devMode) {
        document.getElementById('dev-controls').style.display = 'block';
        document.getElementById('dev-code-input').parentElement.style.display = 'none';
    }
}

function closeSettings() {
    document.getElementById('settings-overlay').style.display = 'none';
}

function checkDevCode() {
    const val = document.getElementById('dev-code-input').value;
    if (val === "oiPoipoiDEV") {
        devMode = true;
        showToast("Dev Mode Unlocked!");
        document.getElementById('dev-controls').style.display = 'block';
        document.getElementById('dev-code-input').parentElement.style.display = 'none';
        initPalette(); 
    } else {
        showToast("Incorrect Code");
    }
}

function toggleDevMode(checked) {
    devMode = checked;
    if(devMode) showToast("Limits Disabled");
    else showToast("Limits Enabled");
}

function toggleTheme(isLight) {
    isLightMode = isLight;
    if (isLight) {
        document.body.classList.add('light-mode');
        scene.background = new THREE.Color(CONFIG.colors.skyLight);
        scene.fog = new THREE.FogExp2(CONFIG.colors.skyLight, 0.02);
    } else {
        document.body.classList.remove('light-mode');
        scene.background = new THREE.Color(CONFIG.colors.sky);
        scene.fog = new THREE.FogExp2(CONFIG.colors.sky, 0.02);
    }
}

function toggleAiFeature(checked) {
    aiEnabled = checked;
    localStorage.setItem('voxelverse_ai_enabled', checked);
    updateAiButtonVisibility();
    document.getElementById('ai-key-container').style.display = checked ? 'block' : 'none';
}

function saveApiKey(val) {
    userApiKey = val.trim();
    localStorage.setItem('voxelverse_api_key', userApiKey);
    if(val) showToast("API Key Saved");
}

function updateAiButtonVisibility() {
    const btn = document.getElementById('btn-ai-gen');
    if (btn) btn.style.display = aiEnabled ? 'flex' : 'none';
}

function resetSaveData() {
    if(confirm("Are you sure? This will delete all your worlds.")) {
        localStorage.removeItem('voxelverse_project');
        location.reload();
    }
}

// --- TEXTURE GENERATOR ---
const textureCache = {};
function getTexture(type, color, text, customPixels) {
    const key = type + color + (text || '') + (customPixels ? 'custom' : '');
    if(textureCache[key]) return textureCache[key];

    const canvas = document.createElement('canvas');
    canvas.width = 128; canvas.height = 128; 
    const ctx = canvas.getContext('2d');

    ctx.fillStyle = color;
    ctx.fillRect(0,0,128,128);

    if (type === 'sign') {
        ctx.fillStyle = "#e2e8f0";
        ctx.fillRect(5,5,118,118); 
        ctx.fillStyle = "#1e293b";
        
        const content = text || "Sign";
        let fontSize = 20;
        ctx.font = `bold ${fontSize}px Arial`;
        let textWidth = ctx.measureText(content).width;
        while(textWidth > 100 && fontSize > 10) {
            fontSize--;
            ctx.font = `bold ${fontSize}px Arial`;
            textWidth = ctx.measureText(content).width;
        }
        ctx.textAlign = "center"; ctx.textBaseline = "middle";
        ctx.fillText(content, 64, 64);
        ctx.strokeStyle = "#475569"; ctx.lineWidth = 5; ctx.strokeRect(5,5,118,118);
    }
    else if (type === 'brick' || type === 'wood' || type === 'stone' || type === 'sand') {
        ctx.strokeStyle = "rgba(0,0,0,0.2)";
        ctx.lineWidth = 4;
        ctx.strokeRect(0,0,128,128);
        ctx.beginPath(); ctx.moveTo(0,64); ctx.lineTo(128,64); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(64,0); ctx.lineTo(64,64); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(64,64); ctx.lineTo(64,128); ctx.stroke(); 
        if (type === 'stone') addNoise(ctx, 0.2); 
        if (type === 'sand') addNoise(ctx, 0.3); 
    } 
    else if (type === 'log') {
        ctx.strokeStyle = "#5d4037"; ctx.lineWidth = 3;
        ctx.beginPath(); ctx.arc(64,64,50,0,Math.PI*2); ctx.stroke();
        ctx.beginPath(); ctx.arc(64,64,30,0,Math.PI*2); ctx.stroke();
        ctx.beginPath(); ctx.arc(64,64,10,0,Math.PI*2); ctx.stroke();
    }
    else if (type === 'leaves') {
        ctx.fillStyle = "rgba(0,0,0,0.2)";
        for(let i=0; i<40; i++) ctx.fillRect(Math.random()*110, Math.random()*110, 15, 15);
    }
    else if (type === 'grass') {
        ctx.fillStyle = "rgba(255,255,255,0.1)";
        for(let i=0; i<100; i++) ctx.fillRect(Math.random()*128,Math.random()*128, 4, 6);
    }
    else if (type === 'hazard') {
        ctx.fillStyle = "#fbbf24"; 
        for(let i=-128; i<128; i+=32) {
            ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i+16,0); ctx.lineTo(i+144,128); ctx.lineTo(i+128,128); ctx.fill();
        }
    }
    else if (type === 'bounce') {
        ctx.strokeStyle = "rgba(255,255,255,0.6)"; ctx.lineWidth=8;
        ctx.beginPath(); ctx.arc(64,64,32,0,Math.PI*2); ctx.stroke();
        ctx.beginPath(); ctx.arc(64,64,16,0,Math.PI*2); ctx.stroke();
    }
    else if (type === 'speed') {
        ctx.fillStyle = "rgba(255,255,255,0.3)";
        ctx.beginPath(); ctx.moveTo(20,128); ctx.lineTo(64,0); ctx.lineTo(108,128); ctx.fill();
    }
    else if (type === 'turret') {
        ctx.fillStyle = "#1e293b"; ctx.fillRect(16,16,96,96); 
        ctx.fillStyle = "#ef4444"; ctx.beginPath(); ctx.arc(64,64,24,0,Math.PI*2); ctx.fill();
        ctx.strokeStyle = "#475569"; ctx.lineWidth=6; ctx.strokeRect(16,16,96,96);
    }
    else if (type === 'teleport') {
        ctx.fillStyle = "#1e1b4b"; ctx.fillRect(0,0,128,128);
        ctx.strokeStyle = "#c084fc"; ctx.lineWidth=4;
        for(let i=1; i<8; i++) {
            ctx.beginPath(); ctx.arc(64,64, i*8, i*0.5, Math.PI+i*0.5); ctx.stroke();
        }
    }
    else if (type === 'ice') {
        ctx.fillStyle = "rgba(255,255,255,0.3)";
        ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(60,128); ctx.lineTo(128,0); ctx.fill();
    }
    else if (type === 'mud') {
        addNoise(ctx, 0.4);
    }
    else if (type === 'goal') {
        ctx.fillStyle = '#fff';
        ctx.fillRect(0,0,64,64); ctx.fillRect(64,64,64,64);
        ctx.fillStyle = '#000';
        ctx.fillRect(64,0,64,64); ctx.fillRect(0,64,64,64);
    }
    else if (type === 'spawn') {
        ctx.fillStyle = "#334155"; ctx.fillRect(0,0,128,128);
        ctx.strokeStyle = "#38bdf8"; ctx.lineWidth=6;
        ctx.beginPath(); ctx.arc(64,64,40,0,Math.PI*2); ctx.stroke();
        ctx.fillStyle = "#38bdf8"; ctx.font="60px Arial"; ctx.textAlign="center"; ctx.fillText("H", 64, 84);
    }
    else if (type === 'ladder') {
        ctx.strokeStyle = "#854d0e"; ctx.lineWidth = 8;
        ctx.beginPath(); ctx.moveTo(32,0); ctx.lineTo(32,128); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(96,0); ctx.lineTo(96,128); ctx.stroke();
        ctx.lineWidth = 6;
        for(let i=16; i<128; i+=32) {
            ctx.beginPath(); ctx.moveTo(32,i); ctx.lineTo(96,i); ctx.stroke();
        }
    }
    else if (type === 'light') {
        ctx.fillStyle = "#fef08a"; ctx.fillRect(32,32,64,64);
    }

    const tex = new THREE.CanvasTexture(canvas);
    tex.magFilter = THREE.NearestFilter;
    textureCache[key] = tex;
    return tex;
}

function addNoise(ctx, alpha) {
    ctx.fillStyle = `rgba(0,0,0,${alpha})`;
    for(let i=0; i<300; i++) ctx.fillRect(Math.random()*128, Math.random()*128, 2, 2);
}

// --- TOOLS & PALETTE ---
let TOOLS = {
    'sign':  { name: 'Sign', type: 'solid', color: '#64748b', tex: 'sign', icon: 'ü™ß', shape: 'sign' },
    'brick': { name: 'Brick', type: 'solid', color: '#8d6e63', tex: 'brick', icon: 'üß±' },
    'grass': { name: 'Grass', type: 'solid', color: '#4ade80', tex: 'grass', icon: 'üåø' },
    'wood':  { name: 'Wood',  type: 'solid', color: '#d7ccc8', tex: 'wood', icon: 'ü™µ' },
    'stone': { name: 'Stone', type: 'solid', color: '#94a3b8', tex: 'stone', icon: 'ü™®' },
    'sand':  { name: 'Sand',  type: 'solid', color: '#fde047', tex: 'sand', icon: 'üèúÔ∏è' },
    'log':   { name: 'Log',   type: 'solid', color: '#78350f', tex: 'log', icon: 'üå≥' },
    'leaves':{ name: 'Leaves',type: 'solid', color: '#166534', tex: 'leaves', icon: 'üçÉ' },
    'glass': { name: 'Glass', type: 'solid', color: '#a5f3fc', tex: 'ice', icon: 'üßä', opacity: 0.3 },
    'light': { name: 'Light', type: 'solid', color: '#fef08a', tex: 'light', icon: 'üí°', emissive: 0xffffee },
    'ladder':{ name: 'Ladder', type: 'climb', color: '#a16207', tex: 'ladder', icon: 'ü™ú', isClimb: true },
    'ice':   { name: 'Ice',   type: 'solid', color: '#cffafe', tex: 'ice', icon: '‚ùÑÔ∏è', friction: 1.0 },
    'mud':   { name: 'Mud',   type: 'solid', color: '#5D4037', tex: 'mud', icon: 'üí©', speed: 0.4 },
    'lava':  { name: 'Lava',  type: 'hazard', color: '#ef4444', tex: 'hazard', icon: 'üî•', emissive: 0xaa0000 },
    'bounce':{ name: 'Jump Pad', type: 'solid', color: '#d946ef', tex: 'bounce', icon: '‚è´', bounce: 1.8 },
    'coin':  { name: 'Coin',  type: 'collectible', color: '#fbbf24', icon: 'ü™ô', shape: 'coin' },
    'spawn': { name: 'Start', type: 'spawn', color: '#ffffff', tex: 'spawn', icon: 'üèÅ', opacity: 1.0, shape: 'cylinder' },
    'goal':  { name: 'Finish', type: 'goal', color: '#3b82f6', tex: 'goal', icon: 'üèÜ' }
};

const DEV_TOOLS = {
    'turret': { name: 'Turret', type: 'hazard', color: '#334155', tex: 'turret', icon: 'üî´', isTurret: true },
    'tp':     { name: 'Teleport', type: 'trigger', color: '#312e81', tex: 'teleport', icon: 'üåÄ', isTP: true },
    'speed':  { name: 'Speed Pad', type: 'solid', color: '#f59e0b', tex: 'speed', icon: '‚ö°', speed: 2.5 }
};

function initPalette() {
    const p = document.getElementById('palette');
    if (!p) return; 
    p.innerHTML = '';
    
    const allTools = { ...TOOLS, ...(devMode ? DEV_TOOLS : {}) };
    if (project.customBlocks) {
        project.customBlocks.forEach(cb => { allTools[cb.id] = cb; });
    }

    Object.entries(allTools).forEach(([key, tool]) => {
        const el = document.createElement('div');
        el.className = `tool-item ${currentBlockType === key ? 'selected' : ''} ${devMode && DEV_TOOLS[key] ? 'dev-item' : ''} ${tool.isCustom ? 'custom-item' : ''}`;
        el.onclick = () => {
            currentBlockType = key;
            document.querySelectorAll('.tool-item').forEach(e => e.classList.remove('selected'));
            el.classList.add('selected');
        };
        el.innerHTML = `<div class="tool-icon">${tool.icon || 'üì¶'}</div><div class="tool-label">${tool.name}</div>`;
        p.appendChild(el);
    });
}

function createCustomBlockFromUI() {
    const name = document.getElementById('bm-name').value || "My Block";
    const color = document.getElementById('bm-color').value;
    const type = document.getElementById('bm-type').value;
    const force = parseFloat(document.getElementById('bm-force').value) || 1.0;
    const script = document.getElementById('bm-script').value;
    
    const id = 'custom_' + Date.now();
    const newBlock = {
        id: id, name: name, color: color,
        type: type === 'hazard' || type === 'bounce' || type === 'speed' ? 'solid' : 'solid', 
        tex: 'custom', icon: 'üì¶', isCustom: true, customPixels: [...painterPixels], 
        gameType: type === 'hazard' ? 'hazard' : 'solid',
        bounce: type === 'bounce' ? force : 0,
        friction: type === 'ice' ? 0.05 : (type === 'mud' ? 50 : 10), 
        speed: type === 'mud' ? 0.4 : (type === 'speed' ? force : 1),
        script: script
    };
    
    if (type === 'ice') newBlock.friction = 0.5;
    if (type === 'mud') newBlock.friction = 20;

    if (!project.customBlocks) project.customBlocks = [];
    project.customBlocks.push(newBlock);
    
    saveProject();
    initPalette();
    showToast("Block Created!");
}

function updateBuildLayer(val) {
    if(!devMode) {
        if(val > LIMITS.LAYER_MAX) val = LIMITS.LAYER_MAX;
        if(val < LIMITS.LAYER_MIN) val = LIMITS.LAYER_MIN;
    }
    buildLayerY = parseInt(val) || 0;
    document.getElementById('layer-input').value = buildLayerY;
    gridHelper.position.y = buildLayerY; 
}

function toggleForceLayer(checked) { forceLayer = checked; }
function updateBuildScale() {
    buildScale.x = parseFloat(document.getElementById('scale-x').value) || 1;
    buildScale.y = parseFloat(document.getElementById('scale-y').value) || 1;
    buildScale.z = parseFloat(document.getElementById('scale-z').value) || 1;
}

// --- OBJECT MANAGEMENT ---

function createMesh(type, x, y, z, text, scaleVal = {x:1,y:1,z:1}) {
    let data = TOOLS[type] || DEV_TOOLS[type];
    if (!data && project.customBlocks) data = project.customBlocks.find(b => b.id === type);
    if (!data) return null;
    
    let geo, mat;
    const sx = scaleVal.x || 1; const sy = scaleVal.y || 1; const sz = scaleVal.z || 1;

    if (data.shape === 'coin') {
        geo = new THREE.CylinderGeometry(0.3 * Math.min(sx,sz), 0.3 * Math.min(sx,sz), 0.05 * sy, 16);
        geo.rotateX(Math.PI/2);
    } else if (data.shape === 'cylinder') {
        geo = new THREE.CylinderGeometry(0.4 * Math.min(sx,sz), 0.4 * Math.min(sx,sz), 0.2 * sy, 16);
        geo.translate(0, 0.1 * sy, 0); 
    } else if (data.shape === 'sign') {
        geo = new THREE.BoxGeometry(0.8 * sx, 0.8 * sy, 0.1 * sz);
        geo.translate(0, 0.5 * sy, 0);
    } else {
        geo = new THREE.BoxGeometry(1 * sx, 1 * sy, 1 * sz);
        geo.translate(0, 0.5 * sy, 0);
    }

    const matProps = { color: data.color };
    if (data.tex) matProps.map = getTexture(data.tex, data.color, text, data.customPixels); 
    if (data.opacity) { matProps.transparent = true; matProps.opacity = data.opacity; }
    if (data.emissive) { matProps.emissive = data.emissive; matProps.emissiveIntensity = 0.5; }
    
    mat = new THREE.MeshStandardMaterial(matProps);
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(x, y, z);
    
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    
    mesh.userData = { 
        type: type, 
        gameType: data.gameType || data.type, 
        bounce: data.bounce || 0,
        friction: data.friction !== undefined ? data.friction : 10,
        speed: data.speed !== undefined ? data.speed : 1,
        isTurret: data.isTurret,
        isTP: data.isTP,
        isClimb: data.isClimb,
        lastFire: 0,
        text: text,
        scale: {x:sx, y:sy, z:sz},
        script: data.script
    };
    
    mesh.scale.set(0,0,0);
    new TWEEN(mesh.scale).to({x:1, y:1, z:1}, 400).easing(easingElastic).start();

    return mesh;
}

function addObject(x, y, z, type, text = null, scaleOverride = null) {
    if (currentTool === 'eraser' || currentTool === 'pick') return; 

    if (!devMode && objects.length >= LIMITS.BLOCKS) {
        if(!isFillMode) showToast("Block Limit Reached! (2000)");
        return;
    }

    const exist = objects.find(o => Math.abs(o.position.x - x) < 0.1 && Math.abs(o.position.y - y) < 0.1 && Math.abs(o.position.z - z) < 0.1);
    if (exist) return;

    if (type === 'spawn') {
        const oldSpawn = objects.find(o => o.userData.type === 'spawn');
        if(oldSpawn) removeObject(oldSpawn);
    }

    const s = scaleOverride || buildScale;
    const mesh = createMesh(type, x, y, z, text, s);
    if(mesh) {
        scene.add(mesh);
        objects.push(mesh);
    }
}

function removeObject(obj) {
    scene.remove(obj);
    objects = objects.filter(o => o !== obj);
}

function clearCurrentLevel() {
    if(!confirm("Are you sure you want to clear this level?")) return;
    objects.forEach(o => scene.remove(o));
    objects = [];
    addObject(0, 0, 0, 'grass');
    addObject(0, 1, 0, 'spawn');
}

// --- LEVEL SYSTEM ---

function getLevelList() {
    const sel = document.getElementById('level-select');
    if (!sel) return; 
    sel.innerHTML = '';
    project.levels.forEach((lvl, idx) => {
        const opt = document.createElement('option');
        opt.value = lvl.id;
        opt.innerText = lvl.name;
        if(lvl.id === project.currentLevelId) opt.selected = true;
        sel.appendChild(opt);
    });
}

function saveCurrentLevelState() {
    const lvl = project.levels.find(l => l.id === project.currentLevelId);
    if(!lvl) return; 
    lvl.objects = objects.map(o => ({
        type: o.userData.type,
        x: o.position.x, y: o.position.y, z: o.position.z,
        text: o.userData.text, scale: o.userData.scale 
    }));
}

function loadLevel(id, skipSave = false) {
    if(mode === 'edit' && !skipSave && project.levels.find(l => l.id === project.currentLevelId)) {
        saveCurrentLevelState();
    }
    
    objects.forEach(o => scene.remove(o));
    objects = [];

    const lvl = project.levels.find(l => l.id === id);
    if(!lvl) return;

    project.currentLevelId = id;
    
    lvl.objects.forEach(data => {
        let s = data.scale;
        if (typeof s === 'number') s = {x:s, y:s, z:s};
        if (!s) s = {x:1, y:1, z:1};
        const mesh = createMesh(data.type, data.x, data.y, data.z, data.text, s);
        if(mesh) {
            scene.add(mesh);
            objects.push(mesh);
        }
    });
    
    getLevelList();
}

function performAddLevel(name) {
    saveCurrentLevelState();
    const id = 'lvl_' + Date.now();
    project.levels.push({ id: id, name: name, objects: [] });
    loadLevel(id);
    addObject(0,0,0,'grass');
    addObject(0,1,0,'spawn');
}

function deleteLevel() {
    if(project.levels.length <= 1) { alert("Cannot delete the last level!"); return; }
    if(!confirm("Delete this level?")) return;
    
    const idx = project.levels.findIndex(l => l.id === project.currentLevelId);
    project.levels.splice(idx, 1);
    
    const newId = project.levels[0].id;
    project.currentLevelId = newId; 
    objects = []; 
    loadLevel(newId, true); 
}

function switchLevel(id) {
    loadLevel(id);
}

// --- EXPORT & SAVE & IMPORT ---

function saveProject() {
    saveCurrentLevelState();
    const saveState = { project, devMode };
    localStorage.setItem('voxelverse_project', JSON.stringify(saveState));
    showToast("Project Saved!");
}

function loadProject() {
    const raw = localStorage.getItem('voxelverse_project');
    if(!raw) { showToast("No saved project found."); return; }
    const data = JSON.parse(raw);
    
    if (data.project) {
        project = data.project;
        devMode = data.devMode || false;
    } else {
        project = data; 
    }
    
    if (devMode) initPalette();
    loadLevel(project.levels[0].id);
    showToast("Project Loaded!");
}

function startGame() {
    document.getElementById('start-screen').style.display = 'none';
    togglePlayMode();
}

function performExport(title, btnText) {
    saveCurrentLevelState();
    
    const currentLvl = project.levels.find(l => l.id === project.currentLevelId);
    if (!currentLvl.objects.some(o => o.type === 'spawn')) {
        alert(`Warning: Current level (${currentLvl.name}) has no 'Start' point.`);
    }

    const json = JSON.stringify(project);
    const b64 = btoa(encodeURIComponent(json).replace(/%([0-9A-F]{2})/g, function(match, p1) { return String.fromCharCode('0x' + p1); }));
    
    const clone = document.documentElement.cloneNode(true);
    clone.querySelector('body').classList.add('exported');
    
    const titleEl = clone.querySelector('#start-screen h1');
    if(titleEl) titleEl.innerText = title;
    
    const btnEl = clone.querySelector('#start-screen .btn');
    if(btnEl) btnEl.innerText = btnText;
    
    const pageTitle = clone.querySelector('title');
    if(pageTitle) pageTitle.innerText = title;

    const toRemove = ['#toolbar', '#palette', '#controls-info', '#modal-overlay', '#import-file', '#settings-overlay'];
    toRemove.forEach(sel => {
        const el = clone.querySelector(sel);
        if(el) el.remove();
    });

    const dataComment = document.createComment(`VOXELDATA[${b64}]`);
    clone.appendChild(dataComment);

    const script = document.createElement('script');
    script.textContent = `
        window.IS_EXPORTED_GAME = true;
        const raw = "${b64}";
        window.EXPORTED_PROJECT = JSON.parse(decodeURIComponent(Array.prototype.map.call(atob(raw), c => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)).join('')));
    `;
    clone.querySelector('head').insertBefore(script, clone.querySelector('head').firstChild);

    const html = clone.outerHTML;
    const blob = new Blob([html], {type: 'text/html'});
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = 'index.html'; 
    a.click();
    showToast("Exported index.html!");
}

function openExportModal() {
    openExportModal(); // Re-use modal logic
}

function openImport() {
    document.getElementById('import-file').click();
}

function handleFileSelect(input) {
    const file = input.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = function(e) {
        const content = e.target.result;
        const startMarker = "VOXELDATA[";
        const startIndex = content.indexOf(startMarker);
        
        if (startIndex !== -1) {
            try {
                const start = startIndex + startMarker.length;
                const end = content.indexOf("]", start);
                const raw = content.substring(start, end);
                const json = decodeURIComponent(Array.prototype.map.call(atob(raw), c => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)).join(''));
                const importedProject = JSON.parse(json);
                project = importedProject;
                if(project.customBlocks) initPalette(); 
                const startId = project.currentLevelId || project.levels[0].id;
                loadLevel(startId); 
                showToast("Game Imported!");
            } catch (err) { console.error(err); showToast("Error parsing file."); }
        } else {
             // Fallback for older saves
            const match = content.match(/const\s+raw\s*=\s*"([^"]+)"/);
            if(match && match[1]) {
                 try {
                    const raw = match[1];
                    const json = decodeURIComponent(Array.prototype.map.call(atob(raw), c => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)).join(''));
                    project = JSON.parse(json);
                    loadLevel(project.levels[0].id);
                    showToast("Legacy Game Imported!");
                 } catch(e) { showToast("Invalid File"); }
            } else {
                showToast("Invalid VoxelVerse file.");
            }
        }
    };
    reader.readAsText(file);
    input.value = '';
}

// --- DEMO LEVELS ---
function createDemoLevels() {
    const tutorial = {
        id: 'lvl1', name: 'Tutorial',
        objects: [
            {x:0,y:0,z:0,type:'grass'}, {x:0,y:0,z:0,type:'spawn'}, 
            {x:0,y:1,z:2,type:'sign', text:"WASD Move"},
            {x:0,y:0,z:-1,type:'grass'}, {x:0,y:0,z:-2,type:'grass'},
            {x:0,y:0,z:-3,type:'brick'}, {x:0,y:1,z:-3,type:'brick'},
            {x:-2,y:1,z:-3,type:'sign', text:"Space Jump"},
            {x:0,y:0,z:-4,type:'grass'}, {x:0,y:0,z:-5,type:'grass'},
            {x:0,y:0,z:-6,type:'bounce'},
            {x:2,y:1,z:-6,type:'sign', text:"Jump Pad"},
            {x:0,y:3,z:-8,type:'brick'}, {x:0,y:3,z:-9,type:'brick'},
            {x:0,y:3,z:-10,type:'goal'}
        ]
    };
    const parkour = {
        id: 'lvl2', name: 'Parkour',
        objects: [
            {x:0,y:0,z:0,type:'wood'}, {x:0,y:0,z:0,type:'spawn'},
            {x:0,y:0,z:-3,type:'wood'}, {x:0,y:1,z:-6,type:'wood'},
            {x:0,y:2,z:-9,type:'wood'}, {x:0,y:3,z:-12,type:'wood'},
            {x:2,y:4,z:-12,type:'ice'}, {x:4,y:4,z:-12,type:'ice'},
            {x:6,y:5,z:-12,type:'goal'}
        ]
    };
    project.levels = [tutorial, parkour];
    project.currentLevelId = 'lvl1';
    loadLevel('lvl1', true);
}

// --- GAME LOOP & LOGIC ---

const ghostBox = new THREE.Mesh(
    new THREE.BoxGeometry(1,1,1).translate(0,0.5,0),
    new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.3, wireframe: true })
);
scene.add(ghostBox);

function updateEditor(dt) {
    const speed = input.keys['ShiftLeft'] ? 20 : 10;
    
    // Rotation handled in mousemove
    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
    const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
    
    if (document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA') {
        if (input.keys['KeyW']) camera.position.add(forward.multiplyScalar(speed * dt));
        if (input.keys['KeyS']) camera.position.add(forward.multiplyScalar(-speed * dt));
        if (input.keys['KeyA']) camera.position.add(right.multiplyScalar(-speed * dt));
        if (input.keys['KeyD']) camera.position.add(right.multiplyScalar(speed * dt));
        if (input.keys['Space']) camera.position.y += speed * dt;
        if (input.keys['ControlLeft'] || input.keys['ControlRight']) camera.position.y -= speed * dt;
    }

    const ray = new THREE.Raycaster();
    ray.setFromCamera(input.mouse, camera);
    const intersects = ray.intersectObjects(objects);
    
    // TOOL LOGIC
    if (currentTool === 'eraser' || currentTool === 'pick') {
        if (intersects.length > 0) {
            const hitObj = intersects[0].object;
            ghostBox.position.copy(hitObj.position);
            const s = hitObj.userData.scale || {x:1,y:1,z:1};
            ghostBox.scale.set(s.x*1.05, s.y*1.05, s.z*1.05); 
            const color = currentTool === 'eraser' ? 0xff0000 : 0x00ff00;
            ghostBox.material.color.setHex(color);
            ghostBox.visible = true;
            
            if (input.mouseDown) {
                if (currentTool === 'eraser') {
                     removeObject(hitObj);
                } else if (currentTool === 'pick') {
                     currentBlockType = hitObj.userData.type;
                     const s = hitObj.userData.scale;
                     document.getElementById('scale-x').value = s.x;
                     document.getElementById('scale-y').value = s.y;
                     document.getElementById('scale-z').value = s.z;
                     updateBuildScale();
                     document.querySelectorAll('.tool-item').forEach(e => {
                         e.classList.remove('selected');
                         if(e.innerText.includes(currentBlockType)) e.classList.add('selected'); 
                     });
                     selectToolMode('brush');
                     showToast("Picked: " + currentBlockType);
                }
                input.mouseDown = false;
            }
        } else {
            ghostBox.visible = false;
        }
    } else {
        // BRUSH OR FILL
        let targetPos = new THREE.Vector3();
        let valid = false;

        if (forceLayer) {
             const plane = new THREE.Plane(new THREE.Vector3(0,1,0), -buildLayerY);
             const intersection = ray.ray.intersectPlane(plane, targetPos);
             valid = !!intersection;
        } 
        else if (intersects.length > 0) {
            const hit = intersects[0];
            targetPos.copy(hit.point).add(hit.face.normal.multiplyScalar(0.5));
            valid = true;
        } else {
            const plane = new THREE.Plane(new THREE.Vector3(0,1,0), -buildLayerY);
            const intersection = ray.ray.intersectPlane(plane, targetPos);
            valid = !!intersection;
        }

        if (valid) {
            const x = Math.round(targetPos.x);
            const y = Math.floor(targetPos.y + 0.01); 
            const z = Math.round(targetPos.z);
            
            if (!devMode) {
                if (Math.abs(x) > LIMITS.SIZE || Math.abs(z) > LIMITS.SIZE) valid = false;
                if (y > LIMITS.LAYER_MAX || y < LIMITS.LAYER_MIN) valid = false;
            }

            if (valid) {
                // Ghost Visuals
                if (currentTool === 'fill' && fillStart) {
                    const minX = Math.min(fillStart.x, x);
                    const maxX = Math.max(fillStart.x, x);
                    const minY = Math.min(fillStart.y, y);
                    const maxY = Math.max(fillStart.y, y);
                    const minZ = Math.min(fillStart.z, z);
                    const maxZ = Math.max(fillStart.z, z);
                    
                    const width = (maxX - minX) + 1; 
                    const height = (maxY - minY) + 1;
                    const depth = (maxZ - minZ) + 1;
                    
                    ghostBox.scale.set(width, height, depth);
                    ghostBox.position.set(minX + (width-1)/2, minY, minZ + (depth-1)/2); 
                    ghostBox.material.color.setHex(0xff00ff);
                } else {
                    ghostBox.position.set(x, y, z);
                    ghostBox.scale.set(buildScale.x, buildScale.y, buildScale.z);
                    ghostBox.material.color.setHex(0xffffff);
                }
                ghostBox.visible = true;

                if (input.mouseDown) {
                    if (currentTool === 'fill') {
                        if(!fillStart) {
                            fillStart = {x,y,z};
                            showToast("Start Point Set");
                        } else {
                            const minX = Math.min(fillStart.x, x);
                            const maxX = Math.max(fillStart.x, x);
                            const minY = Math.min(fillStart.y, y);
                            const maxY = Math.max(fillStart.y, y);
                            const minZ = Math.min(fillStart.z, z);
                            const maxZ = Math.max(fillStart.z, z);
                            
                            let count = (maxX-minX+1)*(maxY-minY+1)*(maxZ-minZ+1);
                            
                            if (!devMode && count > 500) {
                                alert("Area too big! Max 500 blocks.");
                            } else {
                                if (currentBlockType === 'sign') {
                                    alert("Cannot fill with Signs.");
                                } else {
                                    for(let ix=minX; ix<=maxX; ix++) {
                                        for(let iy=minY; iy<=maxY; iy++) {
                                            for(let iz=minZ; iz<=maxZ; iz++) {
                                                addObject(ix, iy, iz, currentBlockType);
                                            }
                                        }
                                    }
                                }
                            }
                            fillStart = null;
                        }
                    } 
                    else if (currentBlockType === 'sign') {
                        pendingPlaceCoords = {x, y, z};
                        openModal('sign');
                    } 
                    else {
                        addObject(x, y, z, currentBlockType);
                    }
                    input.mouseDown = false; 
                }
            } else {
                ghostBox.visible = false;
            }
        } else {
            ghostBox.visible = false;
        }
    }
}

function updateGame(dt) {
    if (gameEnded) {
        player.vel.set(0, 0.5, 0); 
        player.pos.addScaledVector(player.vel, dt);
        camera.position.copy(player.pos);
        return; 
    }

    if (input.keys['KeyG'] && devMode) {
        godMode = !godMode;
        input.keys['KeyG'] = false; 
        document.getElementById('god-mode-indicator').style.display = godMode ? 'block' : 'none';
        showToast(godMode ? "God Mode ON" : "God Mode OFF");
    }

    const rayDown = new THREE.Raycaster(player.pos.clone().add(new THREE.Vector3(0, 0.1, 0)), new THREE.Vector3(0,-1,0), 0, 1.2);
    const floorHits = rayDown.intersectObjects(objects);
    
    player.friction = 10;
    player.speedMod = 1;
    player.onLadder = false;

    if (floorHits.length > 0 && player.onGround) {
        const floorObj = floorHits[0].object;
        player.friction = floorObj.userData.friction;
        player.speedMod = floorObj.userData.speed;
        
        if (floorObj.userData.gameType === 'hazard' && !godMode) restartLevel();

        if (floorObj.userData.isTP) {
            const targets = objects.filter(o => o.userData.isTP && o !== floorObj);
            if (targets.length > 0) {
                const target = targets[Math.floor(Math.random() * targets.length)];
                player.pos.copy(target.position).add(new THREE.Vector3(0, 2, 0));
                player.vel.set(0,0,0);
                showToast("Warped!");
            }
        }
    } else {
        player.friction = 2; 
    }

    player.vel.y -= CONFIG.gravity * dt;
    
    const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
    fwd.y = 0; fwd.normalize();
    const right = new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion);
    right.y = 0; right.normalize();
    
    const move = new THREE.Vector3();
    if(input.keys['KeyW']) move.add(fwd);
    if(input.keys['KeyS']) move.sub(fwd);
    if(input.keys['KeyA']) move.sub(right);
    if(input.keys['KeyD']) move.add(right);
    if(move.length() > 0) move.normalize();

    const targetSpeed = CONFIG.baseMoveSpeed * player.speedMod;
    const targetVelX = move.x * targetSpeed;
    const targetVelZ = move.z * targetSpeed;
    
    const damping = player.friction * 5; 
    player.vel.x += (targetVelX - player.vel.x) * damping * dt;
    player.vel.z += (targetVelZ - player.vel.z) * damping * dt;

    const steps = 5; 
    const subDt = dt / steps;
    
    for(let i=0; i<steps; i++) {
        let candidate = player.pos.clone();
        candidate.x += player.vel.x * subDt;
        let wallCheck = candidate.clone(); wallCheck.y += 0.05; 
        const colX = checkCol(wallCheck);
        if(!colX) player.pos.x = candidate.x;
        else { if(colX.userData.isClimb) player.onLadder = true; player.vel.x = 0; }

        candidate = player.pos.clone();
        candidate.z += player.vel.z * subDt;
        wallCheck = candidate.clone(); wallCheck.y += 0.05;
        const colZ = checkCol(wallCheck);
        if(!colZ) player.pos.z = candidate.z;
        else { if(colZ.userData.isClimb) player.onLadder = true; player.vel.z = 0; }

        candidate = player.pos.clone();
        candidate.y += player.vel.y * subDt;
        const colY = checkCol(candidate);
        
        if(!colY) {
            player.pos.y = candidate.y;
            player.onGround = false;
        } else {
            if(colY.userData.isClimb) player.onLadder = true;

            if(player.vel.y < 0) { 
                if(!player.onLadder) {
                    player.onGround = true;
                    player.pos.y = colY.box.max.y; 
                    player.vel.y = 0;
                    if (colY.userData.bounce > 0) {
                        player.vel.y = CONFIG.jumpForce * colY.userData.bounce;
                        player.onGround = false;
                    }
                }
            } else { 
                player.vel.y = 0;
            }
        }
    }

    if (player.onLadder) {
        player.vel.y = 0; 
        if(input.keys['KeyW']) player.vel.y = 6;
        if(input.keys['KeyS']) player.vel.y = -6;
        if(input.keys['Space']) player.vel.y = 6; 
        player.pos.y += player.vel.y * dt; 
    }

    const groundCheck = checkCol(player.pos.clone().sub(new THREE.Vector3(0, 0.05, 0)));
    const canJump = player.onGround || (groundCheck !== null) || player.onLadder;

    if (input.keys['Space'] && canJump && !player.onLadder) {
        player.vel.y = CONFIG.jumpForce;
        player.onGround = false;
    }
    
    if (input.keys['KeyR']) restartLevel();
    if (player.pos.y < -10) restartLevel();

    camera.position.copy(player.pos);
    camera.position.y += 1.5; 

    if(player.onGround && groundCheck && groundCheck.userData.script) {
        try { new Function('player', 'block', groundCheck.userData.script)(player, groundCheck.userData); } catch(e) {}
    }

    const now = performance.now();
    objects.forEach(o => {
        if(o.userData.gameType === 'collectible') o.rotation.y += 3 * dt;
        if (o.userData.isTurret) {
            o.lookAt(player.pos);
            const dist = player.pos.distanceTo(o.position);
            if (dist < 20 && now - o.userData.lastFire > 2000) {
                o.userData.lastFire = now;
                const bulletDir = new THREE.Vector3().subVectors(player.pos, o.position).normalize();
                spawnBullet(o.position.clone().add(bulletDir), bulletDir);
            }
        }
    });
    
    updateBullets(dt);
}

function spawnBullet(pos, dir) {
    const geo = new THREE.SphereGeometry(0.2, 8, 8);
    const mat = new THREE.MeshBasicMaterial({ color: 0xff00ff });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.copy(pos);
    scene.add(mesh);
    bullets.push({ mesh, dir, life: 3 });
}

function updateBullets(dt) {
    for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.life -= dt;
        b.mesh.position.addScaledVector(b.dir, 15 * dt);
        if (b.mesh.position.distanceTo(player.pos) < 0.8) {
            if (!godMode) restartLevel();
            scene.remove(b.mesh);
            bullets.splice(i, 1);
            continue;
        }
        if (checkCol(b.mesh.position) || b.life <= 0) {
            scene.remove(b.mesh);
            bullets.splice(i, 1);
        }
    }
}

function checkCol(pos) {
    const r = player.radius;
    const minX = pos.x - r, maxX = pos.x + r;
    const minY = pos.y, maxY = pos.y + player.height;
    const minZ = pos.z - r, maxZ = pos.z + r;

    const playerBox = new THREE.Box3(new THREE.Vector3(minX, minY, minZ), new THREE.Vector3(maxX, maxY, maxZ));

    for(let o of objects) {
        if (!o.visible || o.userData.gameType === 'spawn') continue;
        const s = o.userData.scale || {x:1,y:1,z:1};
        const box = new THREE.Box3();
        box.min.set(o.position.x - 0.5*s.x, o.position.y, o.position.z - 0.5*s.z);
        box.max.set(o.position.x + 0.5*s.x, o.position.y + s.y, o.position.z + 0.5*s.z);

        if (box.intersectsBox(playerBox)) {
            if (o.userData.gameType === 'collectible') {
                o.visible = false;
                score++;
                document.getElementById('coin-count').innerText = score;
                return null;
            }
            if (o.userData.gameType === 'goal') {
                winLevel();
                return null;
            }
            if (o.userData.gameType === 'hazard') {
                if (!godMode) restartLevel();
                return null;
            }
            return { userData: o.userData, box: box };
        }
    }
    return null;
}

// --- STATE MANAGEMENT ---

function togglePlayMode() {
    if (mode === 'edit') {
        const spawn = objects.find(o => o.userData.type === 'spawn');
        if (!spawn) { alert("Place a 'Start' point first!"); return; }
        
        saveCurrentLevelState(); 
        player.pos.copy(spawn.position);
        player.vel.set(0,0,0);
        player.onGround = false;
        score = 0;
        gameEnded = false;
        document.getElementById('coin-count').innerText = 0;
        bullets.forEach(b => scene.remove(b.mesh));
        bullets = [];
        
        objects.forEach(o => { if(o.userData.gameType === 'collectible') o.visible = true; });

        mode = 'play';
        document.body.requestPointerLock();
        
        document.getElementById('toolbar').style.display = 'none';
        document.getElementById('palette').style.display = 'none';
        document.getElementById('play-ui').style.display = 'block';
        document.getElementById('crosshair').style.display = 'block';
        document.getElementById('controls-info').style.display = 'none';
        document.getElementById('credits').style.display = 'none';
        gridHelper.visible = false;
        ghostBox.visible = false;
    } else {
        stopGame();
    }
}

function stopGame() {
    if(isExported && (document.getElementById('game-over').style.display === 'flex')) return; 

    mode = 'edit';
    document.exitPointerLock();
    
    camera.position.set(0, 10, 10);
    camera.lookAt(0,0,0);
    camera.rotation.set(-0.5, 0, 0); 
    
    if(!isExported) {
        document.getElementById('toolbar').style.display = 'flex';
        document.getElementById('palette').style.display = 'flex';
        document.getElementById('controls-info').style.display = 'block';
        document.getElementById('credits').style.display = 'block';
    }
    document.getElementById('play-ui').style.display = 'none';
    document.getElementById('crosshair').style.display = 'none';
    document.getElementById('game-over').style.display = 'none';
    gridHelper.visible = true;
    ghostBox.visible = true;
    bullets.forEach(b => scene.remove(b.mesh));
    bullets = [];
}

function showPauseMenu() {
    if(gameEnded) return;
    document.getElementById('go-title').innerText = "PAUSED";
    document.getElementById('btn-next-level').style.display = 'none';
    document.getElementById('btn-resume').style.display = 'inline-block';
    document.getElementById('game-over').style.display = 'flex';
}

function resumeGame() {
    document.getElementById('game-over').style.display = 'none';
    document.body.requestPointerLock();
}

function winLevel() {
    gameEnded = true;
    document.exitPointerLock();
    const currIdx = project.levels.findIndex(l => l.id === project.currentLevelId);
    const hasNext = currIdx !== -1 && currIdx < project.levels.length - 1;
    document.getElementById('go-title').innerText = hasNext ? "LEVEL COMPLETE" : "GAME COMPLETE";
    document.getElementById('btn-resume').style.display = 'none';
    document.getElementById('btn-next-level').style.display = hasNext ? 'inline-block' : 'none';
    document.getElementById('game-over').style.display = 'flex';
}

function nextLevel() {
    const currIdx = project.levels.findIndex(l => l.id === project.currentLevelId);
    if(currIdx !== -1 && currIdx < project.levels.length - 1) {
        const nextId = project.levels[currIdx + 1].id;
        loadLevel(nextId);
        document.getElementById('game-over').style.display = 'none';
        togglePlayMode();
    }
}

function restartLevel() {
    if (godMode && !gameEnded) return;
    
    if (isExported && !gameEnded) {
        const spawn = objects.find(o => o.userData.type === 'spawn');
        if(spawn) player.pos.copy(spawn.position);
        player.vel.set(0,0,0);
        gameEnded = false;
        bullets.forEach(b => scene.remove(b.mesh));
        bullets = [];
        objects.forEach(o => { if(o.userData.gameType === 'collectible') o.visible = true; });
        return; 
    }

    const spawn = objects.find(o => o.userData.type === 'spawn');
    if(spawn) player.pos.copy(spawn.position);
    player.vel.set(0,0,0);
    gameEnded = false;
    bullets.forEach(b => scene.remove(b.mesh));
    bullets = [];
    objects.forEach(o => { if(o.userData.gameType === 'collectible') o.visible = true; });
    
    if (document.getElementById('game-over').style.display === 'none') {
    } else {
        document.getElementById('game-over').style.display = 'none';
        document.body.requestPointerLock();
    }
}

// --- EVENTS ---

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

window.addEventListener('keydown', e => {
    if(document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') return; 
    input.keys[e.code] = true;
});

window.addEventListener('keyup', e => input.keys[e.code] = false);

window.addEventListener('mousedown', e => {
    if(e.target !== renderer.domElement) return;

    if(e.button === 0) input.mouseDown = true;
    if(e.button === 2) {
        input.rightDown = true;
        if(mode === 'edit') document.body.style.cursor = 'grabbing';
    }
});
window.addEventListener('mouseup', e => {
    if(e.button === 0) input.mouseDown = false;
    if(e.button === 2) {
        input.rightDown = false;
        if(mode === 'edit') document.body.style.cursor = 'default';
    }
});

document.addEventListener('pointerlockchange', () => {
    if(document.pointerLockElement !== document.body && mode === 'play') {
        if(document.getElementById('game-over').style.display === 'none') {
            showPauseMenu();
        }
    }
});

window.addEventListener('contextmenu', e => e.preventDefault());

window.addEventListener('mousemove', e => {
    input.mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
    input.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

    if (mode === 'edit' && input.rightDown) {
        const sensitivity = 0.003;
        camera.rotation.y -= e.movementX * sensitivity;
        camera.rotation.x -= e.movementY * sensitivity;
        camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
    }

    if (mode === 'play' && document.pointerLockElement === document.body) {
        const sensitivity = 0.002;
        camera.rotation.y -= e.movementX * sensitivity;
        camera.rotation.x -= e.movementY * sensitivity;
        camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
    }
});

function showToast(msg) {
    const t = document.getElementById('toast');
    t.innerText = msg;
    t.style.opacity = 1;
    setTimeout(() => t.style.opacity = 0, 2000);
}

function init() {
    initPalette();
    camera.rotation.order = 'YXZ'; 
    camera.position.set(0, 8, 10);
    camera.rotation.set(-0.5, 0, 0); 

    if (window.IS_EXPORTED_GAME) {
        isExported = true;
        const container = document.getElementById('canvas-container');
        while (container.firstChild) container.removeChild(container.firstChild);
        container.appendChild(renderer.domElement);

        project = window.EXPORTED_PROJECT;
        document.body.classList.add('exported');
        userApiKey = localStorage.getItem('voxelverse_api_key') || "";
        aiEnabled = localStorage.getItem('voxelverse_ai_enabled') !== 'false';
        
        document.getElementById('start-screen').style.display = 'flex';
        const startId = project.currentLevelId || project.levels[0].id;
        loadLevel(startId, true); 
    } else {
        userApiKey = localStorage.getItem('voxelverse_api_key') || "";
        aiEnabled = localStorage.getItem('voxelverse_ai_enabled') !== 'false';
        updateAiButtonVisibility();
        if(!localStorage.getItem('voxelverse_project')) {
            createDemoLevels();
        } else {
            loadProject();
        }
    }
    animate();
}

const clock = new THREE.Clock();
function animate() {
    requestAnimationFrame(animate);
    const dt = Math.min(clock.getDelta(), 0.1);
    const time = performance.now();
    for(let i=TWEEN_REGISTRY.length-1; i>=0; i--) {
        if(TWEEN_REGISTRY[i].update(time)) TWEEN_REGISTRY.splice(i, 1);
    }
    if (mode === 'edit') updateEditor(dt);
    else updateGame(dt);
    renderer.render(scene, camera);
}
init();
</script>
</body>
</html>
