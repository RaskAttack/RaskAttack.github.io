<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flippin' Penguins: Elijah Platinum Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&family=Outfit:wght@400;700&display=swap');
        
        body {
            margin: 0;
            overflow: hidden;
            background-color: #020617;
            font-family: 'Outfit', sans-serif;
            color: white;
            user-select: none;
        }
        canvas {
            display: block;
            touch-action: none;
            cursor: none;
        }
        .ui-font { font-family: 'Fredoka One', cursive; }
        .modal {
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(12px);
            border: 2px solid #38bdf8;
            box-shadow: 0 0 40px rgba(56, 189, 248, 0.2);
        }
        .glow-text {
            text-shadow: 0 0 10px rgba(56, 189, 248, 0.8);
        }
    </style>
</head>
<body>

    <div id="game-container" class="relative w-full h-screen flex items-center justify-center bg-[#020617]">
        <canvas id="gameCanvas"></canvas>

        <!-- UI Overlay -->
        <div class="ui-overlay absolute top-6 left-6 pointer-events-none flex flex-col gap-1">
            <div class="flex items-center gap-3">
                <div class="bg-slate-900/80 px-4 py-2 rounded-xl border border-sky-500/30">
                    <span class="text-sky-400 text-xs uppercase tracking-widest font-bold">Area</span>
                    <div class="text-2xl ui-font text-white leading-none" id="level-display">1</div>
                </div>
                <div class="bg-slate-900/80 px-4 py-2 rounded-xl border border-sky-500/30">
                    <span class="text-sky-400 text-xs uppercase tracking-widest font-bold">Fish</span>
                    <div class="text-2xl ui-font text-white leading-none"><span id="fish-display">0</span><span class="text-sky-500/50">/</span><span id="total-fish-display">0</span></div>
                </div>
            </div>
        </div>

        <!-- Audio Toggle (Top Right) -->
        <button id="mute-btn" onclick="toggleMute()" class="absolute top-6 right-6 bg-slate-900/80 p-3 rounded-full border border-sky-500/30 text-white hover:bg-sky-500/20 transition-all z-30 group">
            <span id="mute-icon">ðŸ”Š</span>
        </button>

        <!-- Start Screen -->
        <div id="start-screen" class="absolute inset-0 flex items-center justify-center z-10 p-4">
            <div class="modal p-10 rounded-3xl text-center max-w-lg shadow-2xl transform transition-all">
                <div class="mb-2">
                    <span class="bg-gradient-to-r from-yellow-400 to-orange-500 text-slate-900 text-[10px] font-black px-3 py-1 rounded-full uppercase tracking-tighter">Platinum Elijah Edition</span>
                </div>
                <h1 class="text-6xl ui-font mb-2 text-white glow-text italic tracking-tighter">FLIPPIN' PENGUINS</h1>
                <p class="mb-8 text-slate-400 text-lg">Gravity is just a suggestion.</p>
                
                <div class="grid grid-cols-2 gap-4 mb-8 text-left">
                    <div class="bg-slate-800/50 p-4 rounded-2xl border border-slate-700">
                        <div class="text-sky-400 text-xs font-bold uppercase mb-2">Navigation</div>
                        <div class="text-white font-bold">WASD / ARROWS</div>
                    </div>
                    <div class="bg-slate-800/50 p-4 rounded-2xl border border-slate-700">
                        <div class="text-sky-400 text-xs font-bold uppercase mb-2">Gravity Flip</div>
                        <div class="text-white font-bold">SPACE BAR</div>
                    </div>
                </div>

                <button onclick="startGame()" class="group relative bg-sky-500 hover:bg-sky-400 text-white ui-font text-xl py-4 px-12 rounded-2xl transition-all transform hover:scale-105 active:scale-95 pointer-events-auto overflow-hidden">
                    <span class="relative z-10">BEGIN ADVENTURE</span>
                    <div class="absolute inset-0 bg-white/20 translate-y-full group-hover:translate-y-0 transition-transform duration-300"></div>
                </button>
            </div>
        </div>

        <!-- Message Modal -->
        <div id="message-modal" class="absolute inset-0 flex items-center justify-center z-20 hidden p-4">
            <div class="modal p-10 rounded-3xl text-center max-w-sm shadow-2xl">
                <h2 id="modal-title" class="text-4xl ui-font mb-4 text-white">TITLE</h2>
                <p id="modal-text" class="mb-8 text-slate-300 leading-relaxed">Message goes here.</p>
                <button id="modal-button" class="w-full bg-sky-500 hover:bg-sky-400 text-white ui-font py-4 rounded-2xl transition-all pointer-events-auto">
                    ACTION
                </button>
            </div>
        </div>
    </div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const startScreen = document.getElementById('start-screen');
    const messageModal = document.getElementById('message-modal');
    const modalTitle = document.getElementById('modal-title');
    const modalText = document.getElementById('modal-text');
    const modalButton = document.getElementById('modal-button');
    const levelDisplay = document.getElementById('level-display');
    const fishDisplay = document.getElementById('fish-display');
    const totalFishDisplay = document.getElementById('total-fish-display');
    const muteIcon = document.getElementById('mute-icon');

    // Game Constants
    const GRAVITY = 0.45;
    const FRICTION = 0.82;
    const MOVE_SPEED = 1.6; 
    const MAX_SPEED = 10.5;   
    const PENGUIN_SIZE = 40;

    // Game State
    let gameState = 'START';
    let currentLevel = 0;
    let fishCollected = 0;
    let gravityDir = 1; 
    let lastFlipTime = 0;
    const flipCooldown = 400;
    let particles = [];
    let snowflakes = [];
    let confetti = [];
    let screenShake = 0;

    const player = {
        x: 100,
        y: 100,
        vx: 0,
        vy: 0,
        width: 32,
        height: 44,
        scaleX: 1,
        scaleY: 1,
        facing: 1,
        grounded: false
    };

    const keys = {};

    // --- AUDIO SYSTEM ---
    const AudioSys = {
        ctx: null,
        isMuted: false,
        interval: null,
        tick: 0,

        init() {
            if (!this.ctx) {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (this.ctx.state === 'suspended') {
                this.ctx.resume();
            }
        },

        playTone(freq, type, duration, vol = 0.1) {
            if (this.isMuted || !this.ctx) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
            gain.gain.setValueAtTime(vol, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            osc.start();
            osc.stop(this.ctx.currentTime + duration);
        },

        playNoise(duration, vol = 0.1) {
            if (this.isMuted || !this.ctx) return;
            const bufferSize = this.ctx.sampleRate * duration;
            const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }
            const noise = this.ctx.createBufferSource();
            noise.buffer = buffer;
            const gain = this.ctx.createGain();
            gain.gain.setValueAtTime(vol, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
            noise.connect(gain);
            gain.connect(this.ctx.destination);
            noise.start();
        },

        playFlip() {
            if (this.isMuted || !this.ctx) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.frequency.setValueAtTime(200, this.ctx.currentTime);
            osc.frequency.linearRampToValueAtTime(600, this.ctx.currentTime + 0.15);
            gain.gain.setValueAtTime(0.15, this.ctx.currentTime);
            gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.15);
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            osc.start();
            osc.stop(this.ctx.currentTime + 0.15);
        },

        playCollect() {
            this.playTone(880, 'sine', 0.1, 0.2);
            setTimeout(() => this.playTone(1760, 'sine', 0.2, 0.2), 50);
        },

        playCrash() {
            if (this.isMuted || !this.ctx) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(100, this.ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(10, this.ctx.currentTime + 0.3);
            gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.3);
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            osc.start();
            osc.stop(this.ctx.currentTime + 0.3);
        },

        startMusic() {
            this.init();
            if (this.interval) clearInterval(this.interval);
            this.tick = 0;
            
            // Faster tempo: 150ms per tick (100 BPM 16th notes approx)
            this.interval = setInterval(() => {
                if (gameState !== 'PLAYING') return;

                // --- DRUMS ---
                // Kick on 1 and 3 (of a 4-beat bar, which is every 16 ticks)
                if (this.tick % 4 === 0) { 
                    this.playTone(60, 'square', 0.1, 0.3); // Punchy low kick
                }
                // Snare on 2 and 4
                if (this.tick % 4 === 2) { 
                    this.playNoise(0.1, 0.15); // Snare noise
                }
                // High hats every 8th note
                if (this.tick % 2 === 0) {
                     this.playNoise(0.03, 0.04);
                }

                // --- BASS (Driving Sawtooth) ---
                const bassRoot = [130.8, 130.8, 174.6, 196.0]; // C C F G
                const measure = Math.floor(this.tick / 16) % 4;
                if (this.tick % 2 === 0) {
                     // Alternate octaves for excitement
                     const oct = (this.tick % 4 === 0) ? 1 : 2;
                     this.playTone(bassRoot[measure] / (3-oct), 'sawtooth', 0.1, 0.12);
                }

                // --- LEAD MELODY (Heroic Square Wave) ---
                // C Major Pentatonic + F for flavor: C D E F G A C
                const scale = [523.25, 587.33, 659.25, 698.46, 783.99, 880.00, 1046.50];
                
                // Generative energetic pattern
                if (this.tick % 4 !== 0 || Math.random() > 0.3) {
                    const seed = (this.tick * 7 + measure * 3);
                    const noteIdx = seed % scale.length;
                    
                    // Add some high register accents
                    const pitch = (Math.random() > 0.8) ? scale[noteIdx] * 2 : scale[noteIdx];
                    
                    this.playTone(pitch, 'square', 0.1, 0.08);
                }
                
                this.tick++;
            }, 140);
        },

        stopMusic() {
            if (this.interval) clearInterval(this.interval);
        }
    };

    function toggleMute() {
        AudioSys.isMuted = !AudioSys.isMuted;
        muteIcon.innerText = AudioSys.isMuted ? 'ðŸ”‡' : 'ðŸ”Š';
        if (!AudioSys.isMuted) AudioSys.init();
    }

    function initSnow() {
        snowflakes = [];
        for(let i=0; i<80; i++) {
            snowflakes.push({
                x: Math.random() * 800,
                y: Math.random() * 600,
                r: Math.random() * 2 + 1,
                v: Math.random() * 2 + 1,
                sway: Math.random() * 0.05
            });
        }
    }

    function initConfetti() {
        confetti = [];
        // Spawn 300 confetti pieces above the screen for a continuous rain effect
        for(let i=0; i<300; i++) {
            confetti.push({
                x: Math.random() * 800,
                y: Math.random() * -800, // Start well above screen
                vx: (Math.random() - 0.5) * 4,
                vy: Math.random() * 5 + 3,
                color: `hsl(${Math.random() * 360}, 100%, 70%)`,
                size: Math.random() * 10 + 5,
                swaySpeed: Math.random() * 0.05 + 0.01,
                swayOffset: Math.random() * Math.PI * 2
            });
        }
    }

    // SVG Rendering Functions
    function drawPenguin(ctx, x, y, scaleX, scaleY, gravityDir, facing, time, vx) {
        ctx.save();
        
        // Waddle and Tilt
        const waddleAmount = Math.abs(vx) > 0.1 ? Math.sin(time / 80) * 0.15 : 0;
        const tilt = vx * 0.05;
        
        ctx.translate(x + 16, y + 22);
        ctx.rotate(waddleAmount + tilt);
        ctx.scale(scaleX * facing, scaleY * gravityDir);

        // -- FEET (Behind Body) --
        ctx.fillStyle = '#fb923c';
        ctx.beginPath();
        ctx.ellipse(-6, 20, 6, 3, 0, 0, Math.PI * 2);
        ctx.ellipse(6, 20, 6, 3, 0, 0, Math.PI * 2);
        ctx.fill();

        // -- BODY --
        ctx.fillStyle = '#0f172a';
        ctx.beginPath();
        ctx.moveTo(0, -20);
        ctx.bezierCurveTo(18, -20, 18, 20, 0, 20);
        ctx.bezierCurveTo(-18, 20, -18, -20, 0, -20);
        ctx.fill();

        // -- BELLY (White) --
        ctx.fillStyle = '#f8fafc';
        ctx.beginPath();
        ctx.ellipse(0, 6, 11, 14, 0, 0, Math.PI * 2);
        ctx.fill();

        // -- FACE PATCH (White) --
        ctx.fillStyle = '#f8fafc';
        ctx.beginPath();
        ctx.arc(6, -11, 7, 0, Math.PI * 2);
        ctx.fill();

        // -- EYES --
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(7, -11, 2.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(8, -12, 1, 0, Math.PI * 2);
        ctx.fill();

        // -- BEAK --
        ctx.fillStyle = '#fbbf24';
        ctx.beginPath();
        ctx.moveTo(9, -7);
        ctx.lineTo(17, -4);
        ctx.lineTo(9, -1);
        ctx.quadraticCurveTo(7, -4, 9, -7);
        ctx.fill();
        ctx.strokeStyle = '#d97706';
        ctx.lineWidth = 0.5;
        ctx.stroke();

        // -- SCARF (Red) --
        ctx.strokeStyle = '#ef4444';
        ctx.lineWidth = 5;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.beginPath();
        ctx.moveTo(-8, -4);
        ctx.quadraticCurveTo(0, -1, 8, -4);
        ctx.stroke();

        const trailX = -14 - (vx * 1.5); 
        const trailY = -4 + Math.sin(time/120)*3;
        ctx.beginPath();
        ctx.moveTo(-6, -4);
        ctx.quadraticCurveTo(-10, -6, trailX, trailY);
        ctx.stroke();

        // -- FLIPPERS (Wings) --
        const flap = Math.abs(vx) > 0.1 ? Math.sin(time / 100) * 0.4 : 0.2;
        ctx.fillStyle = '#0f172a';
        ctx.beginPath();
        ctx.ellipse(-2, 2, 5, 12, 0.4 + flap, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    }

    function drawFish(ctx, x, y, time) {
        const hover = Math.sin(time / 200) * 5;
        ctx.save();
        ctx.translate(x + 15, y + 15 + hover);
        
        const grad = ctx.createRadialGradient(0, 0, 2, 0, 0, 15);
        grad.addColorStop(0, 'rgba(56, 189, 248, 0.4)');
        grad.addColorStop(1, 'rgba(56, 189, 248, 0)');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(0, 0, 15, 0, Math.PI*2);
        ctx.fill();

        ctx.fillStyle = '#7dd3fc';
        ctx.beginPath();
        ctx.ellipse(0, 0, 10, 6, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.beginPath();
        ctx.moveTo(-8, 0);
        ctx.lineTo(-14, -5);
        ctx.lineTo(-14, 5);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
    }

    const levels = [
        {   // Level 1: Intro
            platforms: [
                {x: 0, y: 560, w: 800, h: 40}, 
                {x: 0, y: 0, w: 800, h: 40},   
                {x: 0, y: 0, w: 40, h: 600},   
                {x: 760, y: 0, w: 40, h: 600}, 
                {x: 200, y: 420, w: 200, h: 30},
                {x: 450, y: 220, w: 200, h: 30},
            ],
            spikes: [
                {x: 400, y: 530, w: 60, h: 30, dir: 1},
                {x: 250, y: 40, w: 60, h: 30, dir: -1},
            ],
            fish: [
                {x: 290, y: 370, collected: false},
                {x: 540, y: 170, collected: false},
                {x: 710, y: 510, collected: false},
            ],
            exit: {x: 700, y: 40, w: 60, h: 80},
            spawn: {x: 80, y: 500}
        },
        {   // Level 2: The Climb
            platforms: [
                {x: 0, y: 560, w: 800, h: 40},
                {x: 0, y: 0, w: 800, h: 40},
                {x: 0, y: 0, w: 40, h: 600},
                {x: 760, y: 0, w: 40, h: 600},
                {x: 150, y: 450, w: 120, h: 30},
                {x: 350, y: 300, w: 120, h: 30},
                {x: 150, y: 150, w: 120, h: 30},
                {x: 550, y: 400, w: 30, h: 160},
                {x: 550, y: 40, w: 30, h: 200},
            ],
            spikes: [
                {x: 40, y: 530, w: 720, h: 30, dir: 1},
                {x: 350, y: 330, w: 120, h: 20, dir: -1},
                {x: 150, y: 180, w: 120, h: 20, dir: -1},
            ],
            fish: [
                {x: 200, y: 410, collected: false},
                {x: 400, y: 260, collected: false},
                {x: 200, y: 110, collected: false},
                {x: 680, y: 300, collected: false},
            ],
            exit: {x: 680, y: 480, w: 60, h: 80},
            spawn: {x: 80, y: 80}
        },
        {   // Level 3: Gaps
            platforms: [
                {x: 0, y: 560, w: 800, h: 40},
                {x: 0, y: 0, w: 800, h: 40},
                {x: 0, y: 0, w: 40, h: 600},
                {x: 760, y: 0, w: 40, h: 600},
                {x: 140, y: 280, w: 520, h: 40},
                {x: 380, y: 40, w: 40, h: 180},
                {x: 380, y: 380, w: 40, h: 180},
            ],
            spikes: [
                {x: 140, y: 250, w: 200, h: 30, dir: 1},
                {x: 460, y: 320, w: 200, h: 30, dir: -1},
            ],
            fish: [
                {x: 150, y: 100, collected: false},
                {x: 650, y: 100, collected: false},
                {x: 150, y: 450, collected: false},
                {x: 650, y: 450, collected: false},
            ],
            exit: {x: 700, y: 180, w: 60, h: 80},
            spawn: {x: 200, y: 150}
        },
        {   // Level 4: The Chasm (Verticality)
            platforms: [
                {x: 0, y: 560, w: 800, h: 40},
                {x: 0, y: 0, w: 800, h: 40},
                {x: 0, y: 0, w: 40, h: 600},
                {x: 760, y: 0, w: 40, h: 600},
                {x: 40, y: 450, w: 200, h: 30}, // Low Left
                {x: 560, y: 450, w: 200, h: 30}, // Low Right
                {x: 40, y: 150, w: 200, h: 30},  // High Left
                {x: 560, y: 150, w: 200, h: 30}, // High Right
                {x: 350, y: 300, w: 100, h: 30}, // Center
            ],
            spikes: [
                {x: 240, y: 530, w: 320, h: 30, dir: 1}, // Floor Spikes
                {x: 240, y: 40, w: 320, h: 30, dir: -1}, // Ceiling Spikes
                {x: 350, y: 270, w: 100, h: 30, dir: 1}, // Center Top Spikes
                {x: 350, y: 330, w: 100, h: 30, dir: -1}, // Center Bot Spikes
            ],
            fish: [
                {x: 100, y: 400, collected: false},
                {x: 660, y: 400, collected: false},
                {x: 100, y: 100, collected: false},
                {x: 660, y: 100, collected: false},
            ],
            exit: {x: 370, y: 220, w: 60, h: 80}, // Floating exit
            spawn: {x: 80, y: 400}
        },
        {   // Level 5: The Gauntlet
            platforms: [
                {x: 0, y: 560, w: 800, h: 40},
                {x: 0, y: 0, w: 800, h: 40},
                {x: 0, y: 0, w: 40, h: 600},
                {x: 760, y: 0, w: 40, h: 600},
                // Steps
                {x: 100, y: 400, w: 100, h: 20},
                {x: 250, y: 300, w: 100, h: 20},
                {x: 400, y: 200, w: 100, h: 20},
                {x: 550, y: 400, w: 100, h: 20},
            ],
            spikes: [
                {x: 40, y: 40, w: 720, h: 40, dir: -1}, // Ceiling Death
                {x: 40, y: 520, w: 720, h: 40, dir: 1}, // Floor Death
                {x: 250, y: 320, w: 100, h: 20, dir: -1}, // Underside trap
            ],
            fish: [
                {x: 150, y: 350, collected: false},
                {x: 300, y: 250, collected: false},
                {x: 450, y: 150, collected: false},
                {x: 600, y: 350, collected: false},
            ],
            exit: {x: 700, y: 250, w: 60, h: 80},
            spawn: {x: 60, y: 350}
        }
    ];

    function createParticles(x, y, count, color) {
        for (let i = 0; i < count; i++) {
            particles.push({
                x, y,
                vx: (Math.random() - 0.5) * 8,
                vy: (Math.random() - 0.5) * 8,
                life: 1.0,
                color,
                size: Math.random() * 4 + 2
            });
        }
    }

    function resize() {
        const container = document.getElementById('game-container');
        const ratio = 800 / 600;
        let w = container.clientWidth;
        let h = container.clientHeight;

        if (w / h > ratio) { w = h * ratio; } else { h = w / ratio; }

        canvas.width = 800;
        canvas.height = 600;
        canvas.style.width = w + 'px';
        canvas.style.height = h + 'px';
        initSnow();
    }

    window.addEventListener('resize', resize);
    window.addEventListener('keydown', e => {
        keys[e.code] = true;
        if (e.code === 'Space' && gameState === 'PLAYING') {
            const now = Date.now();
            if (now - lastFlipTime > flipCooldown) {
                gravityDir *= -1;
                lastFlipTime = now;
                player.scaleX = 1.4;
                player.scaleY = 0.6;
                screenShake = 5;
                createParticles(player.x + 16, player.y + 22, 10, '#38bdf8');
                AudioSys.playFlip(); // SFX
            }
        }
    });
    window.addEventListener('keyup', e => keys[e.code] = false);

    function initLevel(idx) {
        const level = levels[idx];
        player.x = level.spawn.x;
        player.y = level.spawn.y;
        player.vx = 0;
        player.vy = 0;
        player.facing = 1;
        gravityDir = 1;
        fishCollected = 0;
        particles = [];
        level.fish.forEach(f => f.collected = false);
        
        levelDisplay.innerText = idx + 1;
        fishDisplay.innerText = 0;
        totalFishDisplay.innerText = level.fish.length;
    }

    function startGame() {
        startScreen.classList.add('hidden');
        gameState = 'PLAYING';
        currentLevel = 0;
        initLevel(currentLevel);
        requestAnimationFrame(gameLoop);
        AudioSys.startMusic(); // Start Music
    }

    function showMessage(title, text, btnText, action) {
        gameState = 'MODAL';
        modalTitle.innerText = title;
        modalText.innerText = text;
        modalButton.innerText = btnText;
        modalButton.onclick = () => {
            messageModal.classList.add('hidden');
            action();
        };
        messageModal.classList.remove('hidden');
    }

    function checkCollision(obj1, obj2) {
        return obj1.x < obj2.x + obj2.w &&
               obj1.x + obj1.width > obj2.x &&
               obj1.y < obj2.y + obj2.h &&
               obj1.y + obj1.height > obj2.y;
    }

    function update(time) {
        // --- VISUAL UPDATES (Always Run) ---
        
        // Particles Update
        particles.forEach((p, i) => {
            p.x += p.vx;
            p.y += p.vy;
            p.life -= 0.02;
            if (p.life <= 0) particles.splice(i, 1);
        });

        // Snow Update (Reacts to gravity)
        snowflakes.forEach(s => {
            s.y += s.v * gravityDir;
            s.x += Math.sin(time/1000 + s.sway) * 0.5;
            
            if (gravityDir === 1 && s.y > 600) s.y = -10;
            if (gravityDir === -1 && s.y < -10) s.y = 610;
            if (s.x > 800) s.x = 0;
        });

        // Confetti Update (Looping rain)
        if (confetti.length > 0) {
            confetti.forEach((p) => {
                p.x += p.vx + Math.sin(time/200 + p.swayOffset) * 0.5;
                p.y += p.vy;
                
                // Wrap around logic for continuous rain
                if (p.y > 600) {
                    p.y = -10;
                    p.x = Math.random() * 800;
                }
            });
        }

        // --- GAME LOGIC (Only when PLAYING) ---
        if (gameState !== 'PLAYING') return;

        // Input
        if (keys['ArrowLeft'] || keys['KeyA']) {
            player.vx -= MOVE_SPEED;
            player.facing = -1;
        }
        if (keys['ArrowRight'] || keys['KeyD']) {
            player.vx += MOVE_SPEED;
            player.facing = 1;
        }

        // Physics
        player.vx *= FRICTION;
        player.vy += GRAVITY * gravityDir;

        if (player.vx > MAX_SPEED) player.vx = MAX_SPEED;
        if (player.vx < -MAX_SPEED) player.vx = -MAX_SPEED;

        // Squash and Stretch Lerp
        player.scaleX += (1 - player.scaleX) * 0.15;
        player.scaleY += (1 - player.scaleY) * 0.15;
        if (screenShake > 0) screenShake *= 0.9;

        // Move Horizontal
        player.x += player.vx;
        const level = levels[currentLevel];
        
        level.platforms.forEach(plat => {
            if (checkCollision(player, plat)) {
                if (player.vx > 0) player.x = plat.x - player.width;
                else if (player.vx < 0) player.x = plat.x + plat.w;
                player.vx = 0;
            }
        });

        // Move Vertical
        player.y += player.vy;
        let wasGrounded = player.grounded;
        player.grounded = false;

        level.platforms.forEach(plat => {
            if (checkCollision(player, plat)) {
                if (player.vy * gravityDir > 0) {
                    if (gravityDir === 1) {
                        player.y = plat.y - player.height;
                    } else {
                        player.y = plat.y + plat.h;
                    }
                    player.grounded = true;
                    if (!wasGrounded && Math.abs(player.vy) > 2) {
                        player.scaleX = 1.3;
                        player.scaleY = 0.7;
                        createParticles(player.x + 16, gravityDir === 1 ? player.y + player.height : player.y, 8, '#f8fafc');
                    }
                } else {
                    if (gravityDir === 1) player.y = plat.y + plat.h;
                    else player.y = plat.y - player.height;
                }
                player.vy = 0;
            }
        });

        // Collectibles
        level.fish.forEach(f => {
            if (!f.collected && checkCollision(player, {x: f.x, y: f.y, w: 30, h: 30})) {
                f.collected = true;
                fishCollected++;
                fishDisplay.innerText = fishCollected;
                createParticles(f.x + 15, f.y + 15, 15, '#38bdf8');
                screenShake = 3;
                AudioSys.playCollect(); // SFX
            }
        });

        // Spikes
        level.spikes.forEach(s => {
            if (checkCollision(player, {x: s.x + 8, y: s.y + 8, w: s.w - 16, h: s.h - 16})) {
                die();
            }
        });

        // Exit
        if (fishCollected === level.fish.length) {
            if (checkCollision(player, {x: level.exit.x, y: level.exit.y, w: level.exit.w, h: level.exit.h})) {
                nextLevel();
            }
        }
    }

    function die() {
        createParticles(player.x + 16, player.y + 22, 30, '#0f172a');
        screenShake = 10;
        AudioSys.playCrash(); // SFX
        showMessage("BRRR!", "You froze up! The spikes are too cold.", "TRY AGAIN", () => {
            initLevel(currentLevel);
            gameState = 'PLAYING';
        });
    }

    function nextLevel() {
        if (currentLevel < levels.length - 1) {
            currentLevel++;
            showMessage("SPLENDID!", "The fish are safe. Onwards!", "NEXT LEVEL", () => {
                initLevel(currentLevel);
                gameState = 'PLAYING';
            });
        } else {
            initConfetti();
            showMessage("LEGENDARY!", "You've conquered the Arctic! Elijah approves.", "REPLAY ALL", () => {
                currentLevel = 0;
                initLevel(currentLevel);
                gameState = 'PLAYING';
            });
        }
    }

    function draw(time) {
        ctx.save();
        if (screenShake > 0.5) {
            ctx.translate((Math.random()-0.5)*screenShake, (Math.random()-0.5)*screenShake);
        }

        ctx.fillStyle = '#020617';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Parallax Background
        ctx.fillStyle = '#0f172a';
        for(let i=0; i<5; i++) {
            ctx.fillRect(100 + i*150, 100 + Math.sin(time/1000 + i)*20, 80, 400);
        }

        // Draw Snow (Background Layer)
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        snowflakes.forEach(s => {
            ctx.beginPath();
            ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
            ctx.fill();
        });

        const level = levels[currentLevel];

        // Platforms
        level.platforms.forEach(plat => {
            // Main block
            ctx.fillStyle = '#1e293b';
            ctx.fillRect(plat.x, plat.y, plat.w, plat.h);
            
            // Ice Cap (Visual only, draws on "top" based on gravity dir mostly, but static for now looks fine)
            ctx.fillStyle = '#f8fafc';
            // Draw snow on both sides to look good in both gravities
            if (plat.h > 10) {
                ctx.fillRect(plat.x, plat.y, plat.w, 6);
                ctx.fillRect(plat.x, plat.y + plat.h - 6, plat.w, 6);
            }
            
            // Decorative shine
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.strokeRect(plat.x+2, plat.y+2, plat.w-4, plat.h-4);
        });

        // Spikes (SVG style)
        ctx.fillStyle = '#7dd3fc';
        level.spikes.forEach(s => {
            const count = Math.floor(s.w / 20);
            const sw = s.w / count;
            for(let i=0; i<count; i++) {
                ctx.beginPath();
                if (s.dir === 1) {
                    ctx.moveTo(s.x + i*sw, s.y + s.h);
                    ctx.lineTo(s.x + i*sw + sw/2, s.y);
                    ctx.lineTo(s.x + (i+1)*sw, s.y + s.h);
                } else {
                    ctx.moveTo(s.x + i*sw, s.y);
                    ctx.lineTo(s.x + i*sw + sw/2, s.y + s.h);
                    ctx.lineTo(s.x + (i+1)*sw, s.y);
                }
                ctx.fill();
            }
        });

        // Fish
        level.fish.forEach(f => {
            if (!f.collected) drawFish(ctx, f.x, f.y, time);
        });

        // Exit
        const isReady = fishCollected === level.fish.length;
        ctx.save();
        ctx.translate(level.exit.x + level.exit.w/2, level.exit.y + level.exit.h/2);
        if (isReady) {
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#38bdf8';
            ctx.fillStyle = '#0ea5e9';
        } else {
            ctx.fillStyle = '#1e293b';
        }
        ctx.beginPath();
        ctx.roundRect(-level.exit.w/2, -level.exit.h/2, level.exit.w, level.exit.h, [30, 30, 0, 0]);
        ctx.fill();
        ctx.restore();

        // Particles
        particles.forEach(p => {
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
            ctx.fill();
        });
        ctx.globalAlpha = 1;

        // Player - PASSING TIME AND VELOCITY FOR ANIMATION
        drawPenguin(ctx, player.x, player.y, player.scaleX, player.scaleY, gravityDir, player.facing, time, player.vx);

        // Confetti
        if (confetti.length > 0) {
            confetti.forEach(p => {
                ctx.fillStyle = p.color;
                //ctx.globalAlpha = p.life; // No fade out for rain
                ctx.fillRect(p.x, p.y, p.size, p.size);
            });
            ctx.globalAlpha = 1;
        }

        ctx.restore();
    }

    function gameLoop(time) {
        update(time);
        draw(time);
        if (gameState !== 'START') {
            requestAnimationFrame(gameLoop);
        }
    }

    resize();
    initLevel(0);
</script>
</body>
</html>
